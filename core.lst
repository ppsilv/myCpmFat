# file opened: core.asm
  1   0000              ; CORE.ASM
  2   0000              ; These are Z80-Playground-specific routines that are available for CP/M or other
  3   0000              ; programs to use. They include routines for sending chars to the screen, reading
  4   0000              ; from the keyboard, and dealing with the USB Drive.
  5   0000              ; There is also a small monitor, so if you want to configure the INT
  6   0000              ; button to take you to the monitor, you can.
  7   0000
  8   0000              ; CORE takes the top 3K of memory, $F400 - $FFFF
  9   0000              ; It assembles to 2.53K right now.
 10   0000
 11   0000                  include "locations.asm"
# file opened: locations.asm
  1+  0000              ; locations.asm
  2+  0000              ; Stores the ORG values for the CCP, BDOS, BIOS and CORE
  3+  0000
  4+  0000              ;CORE_START  equ $F600    ; $FFFF - 2.5K
  5+  0000              ;BIOS_START  equ $F400    ; $F600 - 0.5K
  6+  0000              ;BDOS_START  equ $EA00    ; $F400 - 2.5K
  7+  0000              ;CCP_START   equ $DE00    ; $EA00 - 3.0K
  8+  0000
  9+  0000              CORE_START  equ $EC00    ; 5119
 10+  0000              BIOS_START  equ $DC00    ; 4096
 11+  0000              BDOS_START  equ $D000    ; 3072
 12+  0000              CCP_START   equ $B000    ; 8192
 13+  0000
 14+  0000              CORE_SIZE   equ 0xFFFF-CORE_START
 15+  0000              BIOS_SIZE   equ CORE_START-BIOS_START
 16+  0000              BDOS_SIZE   equ BIOS_START-BDOS_START
 17+  0000              CCP_SIZE    equ BDOS_START-CCP_START
# file closed: locations.asm
 12   0000
 13   0000                  org CORE_START
 14   EC00
 15   EC00              ; CORE internal jump table
 16   EC00              ; For future-proofing, all calls are via this jump table.
 17   EC00              ; From external code just jump to "CORE_configure_uart" or similar, which then jumps to "configure_uart".
 18   EC00              ; That way you can change the value of CORE_ORG, re-assemble this file, then in other files
 19   EC00              ; just include the external jump table.
 20   EC00              ; That way it doesn't matter if these routines change location or size, you can always access them from the jump table.
 21   EC00              CORE_start_monitor:
 22   EC00                  ; Start the debugging monitor
 23   EC00 C3 84 EC         jp unimplemented_start_monitor
 24   EC03              CORE_configure_uart:
 25   EC03                  ; Configures the 16550 UART after a reset, setting the baud rate etc.
 26   EC03 C3 94 EC         jp configure_uart
 27   EC06              CORE_print_a:
 28   EC06                  ; Prints whatever is in A to the screen, as a character.
 29   EC06 C3 C1 EC         jp print_a
 30   EC09              CORE_char_in:
 31   EC09                  ; Reads a character from the keyboard into A
 32   EC09 C3 FF EC         jp char_in
 33   EC0C              CORE_char_available:
 34   EC0C                  ; Checks whether a character is available from the keyboard, without actually reading it
 35   EC0C C3 0C ED         jp char_available
 36   EC0F              CORE_short_pause:
 37   EC0F C3 23 ED         jp short_pause
 38   EC12              CORE_medium_pause:
 39   EC12 C3 1E ED         jp medium_pause
 40   EC15              CORE_long_pause:
 41   EC15 C3 19 ED         jp long_pause
 42   EC18
 43   EC18              CORE_disk_toggle:
 44   EC18 C3 2D ED         jp disk_toggle
 45   EC1B              CORE_disk_on:
 46   EC1B C3 3A ED         jp disk_on
 47   EC1E              CORE_disk_off:
 48   EC1E C3 33 ED         jp disk_off
 49   EC21
 50   EC21              CORE_user_toggle:
 51   EC21 C3 48 ED         jp user_toggle
 52   EC24              CORE_user_on:
 53   EC24 C3 41 ED         jp user_on
 54   EC27              CORE_user_off:
 55   EC27 C3 4E ED         jp user_off
 56   EC2A
 57   EC2A              CORE_rom_toggle:
 58   EC2A C3 55 ED         jp rom_toggle
 59   EC2D              CORE_rom_on:
 60   EC2D C3 5B ED         jp rom_on
 61   EC30              CORE_rom_off:
 62   EC30 C3 62 ED         jp rom_off
 63   EC33
 64   EC33              CORE_newline:
 65   EC33                  ; Prints a CR/NL combo
 66   EC33 C3 EE EC         jp newline
 67   EC36              CORE_space:
 68   EC36                  ; prints a space
 69   EC36 C3 F9 EC         jp space
 70   EC39
 71   EC39              CORE_message:
 72   EC39 C3 69 ED         jp message
 73   EC3C              CORE_show_hl_as_hex:
 74   EC3C C3 7E ED         jp show_hl_as_hex
 75   EC3F              CORE_show_all:
 76   EC3F C3 AA ED         jp show_all
 77   EC42
 78   EC42              CORE_dir:
 79   EC42 C3 0E EE         jp dir
 80   EC45              CORE_dir_next:
 81   EC45 C3 12 EF         jp dir_next
 82   EC48              CORE_load_bin_file:
 83   EC48 C3 1D EF         jp load_bin_file
 84   EC4B              CORE_dir_info_read:
 85   EC4B C3 AB EF         jp dir_info_read
 86   EC4E              CORE_dir_info_write:
 87   EC4E C3 CB EF         jp dir_info_write
 88   EC51              CORE_write_to_file:
 89   EC51 C3 05 F0         jp write_to_file
 90   EC54              CORE_erase_file:
 91   EC54 C3 42 F0         jp erase_file
 92   EC57              CORE_check_cpmdisks_structure:
 93   EC57 C3 C6 F0         jp check_cpmdisks_structure
 94   EC5A              CORE_move_to_file_pointer:
 95   EC5A C3 62 F1         jp move_to_file_pointer
 96   EC5D              CORE_set_random_pointer_in_fcb:
 97   EC5D C3 8C F1         jp set_random_pointer_in_fcb
 98   EC60              CORE_copy_filename_to_buffer:
 99   EC60 C3 0A F4         jp copy_filename_to_buffer
100   EC63              CORE_open_file:
101   EC63 C3 82 F3         jp open_file
102   EC66              CORE_create_directory
103   EC66 C3 A3 F3         jp create_directory
104   EC69              CORE_close_file:
105   EC69 C3 95 F3         jp close_file
106   EC6C              CORE_read_from_file:
107   EC6C C3 BC F3         jp read_from_file
108   EC6F              CORE_connect_to_disk:
109   EC6F C3 A8 F2         jp connect_to_disk
110   EC72              CORE_mount_disk:
111   EC72 C3 D7 F2         jp mount_disk
112   EC75              CORE_create_file:
113   EC75 C3 6D F3         jp create_file
114   EC78              CORE_show_a_as_hex:
115   EC78 C3 87 ED         jp show_a_as_hex
116   EC7B              CORE_convert_user_number_to_folder_name:
117   EC7B C3 DC F1         jp convert_user_number_to_folder_name
118   EC7E              CORE_set_file_size_in_fcb:
119   EC7E C3 9B F1         jp set_file_size_in_fcb
120   EC81              CORE_change_to_slot2:
121   EC81 C3 A0 F4         jp change_to_slot2
122   EC84
123   EC84                  include "uart.asm"
# file opened: uart.asm
  1+  EC84              ; uart routines
  2+  EC84              ; These are routines connected with the 16C550 uart.
  3+  EC84
  4+  EC84              unimplemented_start_monitor:
  5+  EC84              	; Not implemented yet
  6+  EC84 C9           	ret
  7+  EC85
  8+  EC85              UART_FREQUENCY: EQU 19660800	; 82C50 | 16C550 CLOCK
  9+  EC85
 10+  EC85 80 00        UART_BAUD_9600:		DW	UART_FREQUENCY/(9600 * 16)
 11+  EC87 55 00        UART_BAUD_14400:	DW	UART_FREQUENCY/(14400 * 16)
 12+  EC89 40 00        UART_BAUD_19200:	DW	UART_FREQUENCY/(19200 * 16)
 13+  EC8B 20 00        UART_BAUD_38400:	DW	UART_FREQUENCY/(38400 * 16)
 14+  EC8D 15 00        UART_BAUD_57600:	DW	UART_FREQUENCY/(57600 * 16)
 15+  EC8F 0A 00        UART_BAUD_115200:	DW	UART_FREQUENCY/(115200 * 16)
 16+  EC91
 17+  EC91              ; Initialises the 16c550c UART for input/output
 18+  EC91              ;configure_uart:
 19+  EC91              	; Configure the UART 16550 after a reset.
 20+  EC91              	; For the sake of definitely getting the job done, let's pause here for ages before doing it.
 21+  EC91              	; Without this pause the Z80 can get started before the UART is ready.
 22+  EC91              	; Don't ask me how I know this.
 23+  EC91              	;
 24+  EC91              	; Pass in the required BAUD rate divisor in b.
 25+  EC91              	; Pass in the required hardware flow control in c.
 26+  EC91              ;	push bc
 27+  EC91              ;	call long_pause
 28+  EC91              ;	pop bc
 29+  EC91
 30+  EC91              ;	LD		A,	0x00
 31+  EC91              ;	OUT 	(uart_IER),A			; Disable interrupts
 32+  EC91
 33+  EC91              ;    ld 		A,	80H                 ; Go into "Divisor Latch Setting mode"
 34+  EC91              ;    out 	(uart_LCR),a            ; by writing 1 into bit 7 of the Line Control register
 35+  EC91              ;    nop								; These tiny "nop" pauses probably do nothing. TODO: Try removing them!
 36+  EC91
 37+  EC91              ;    ld 		A, b                    ; low byte of divisor
 38+  EC91              ;    out 	(uart_tx_rx), A
 39+  EC91              ;    nop
 40+  EC91              ;    ld 		A, 0                          ; high byte
 41+  EC91              ;    out 	(uart_IER), A
 42+  EC91              ;    nop
 43+  EC91
 44+  EC91              ;    ld a,03H                        ; Configure stop bits etc, and exit
 45+  EC91                                                  ; "Divisor latch setting mode"
 46+  EC91
 47+  EC91              ;    out (uart_LCR),a                ; 8 bits, no parity, 1 stop bit, bit 7 = 0
 48+  EC91              ;	nop								; a slight pause to allow the UART to get going
 49+  EC91
 50+  EC91              ;	ld a, 0x81 						;%10000001					; Turn on FIFO, with trigger level of 8.
 51+  EC91              ;	out (uart_ISR), a				; This definitely helps receive 16 chars very fast!
 52+  EC91
 53+  EC91              	;ld a, c
 54+  EC91              	;cp 0
 55+  EC91              	;jr z, flowcontrol_done
 56+  EC91
 57+  EC91              	;LD      A,0x00                  ;no flow control
 58+  EC91              	;ld a, %00100010
 59+  EC91              	;out (uart_MCR), a				; Enable auto flow control for /RTS and /CTS
 60+  EC91              ;	ret
 61+  EC91              flowcontrol_done:
 62+  EC91 00           	nop
 63+  EC92 00           	nop
 64+  EC93 C9               ret
 65+  EC94
 66+  EC94              configure_uart:
 67+  EC94 F5           UART_INIT:	PUSH	AF
 68+  EC95 7E           			LD		A,(HL)
 69+  EC96 23           			INC 	HL
 70+  EC97 66           			LD		H,(HL)
 71+  EC98 6F           			LD 		L,A
 72+  EC99 3E 00        			LD		A,0x00
 72+  EC9B D3 B9          OUT (uart_IER),A	; Disable interrupts
 73+  EC9D 3E 80        			LD		A,0x80
 73+  EC9F D3 BB          OUT (uart_LCR),A 	; Turn DLAB on
 74+  ECA1 7D           			LD		A,L
 74+  ECA2 D3 B8         	OUT (uart_tx_rx),A	; Set divisor low
 75+  ECA4 7C           			LD		A,H
 75+  ECA5 D3 B9         	OUT (uart_IER),A	; Set divisor high
 76+  ECA7 F1           			POP		AF
 76+  ECA8 D3 BB         		OUT (uart_LCR),A	; Write out flow control bits 8,1,N
 77+  ECAA 3E 81        			LD 		A, 0x81						; Turn on FIFO, with trigger level of 8.
 78+  ECAC D3 BA        			OUT (uart_ISR), A					; This turn on the 16bytes buffer!
 79+  ECAE C9           			RET
 80+  ECAF
 81+  ECAF              UART_TX_WAIT		EQU	600		; Count before a TX times out
 82+  ECAF
 83+  ECAF              ; A: Data read
 84+  ECAF              ; Returns:
 85+  ECAF              ; F = C if character read
 86+  ECAF              ; F = NC if no character read
 87+  ECAF              ;
 88+  ECAF DB BD        UART_RX:	IN	A,(uart_LSR)		; Get the line status register
 89+  ECB1 E6 01        			AND 	0x01				; Check for characters in buffer
 90+  ECB3 C8           			ret	Z					; Just ret (with carry clear) if no characters
 91+  ECB4 DB B8        			IN	A,(uart_tx_rx)		; Read the character from the UART receive buffer
 92+  ECB6 37           			SCF 						; Set the carry flag
 93+  ECB7 C9           			RET
 94+  ECB8
 95+  ECB8              ; Read a character - waits for input
 96+  ECB8              ; NB is the non-blocking variant
 97+  ECB8              ;  A: ASCII character read
 98+  ECB8              ;  F: NC if no character read (non-blocking)
 99+  ECB8              ;  F:  C if character read (non-blocking)
100+  ECB8              ;
101+  ECB8 CD AF EC     Read_Char:              CALL    UART_RX
102+  ECBB 30 FB                                JR      NC,Read_Char
103+  ECBD C9                                   RET
104+  ECBE              ; Read a character - NO waits for input
105+  ECBE              ; NB is the non-blocking variant
106+  ECBE              ;  A: ASCII character read
107+  ECBE              ;  F: NC if no character read (non-blocking)
108+  ECBE              ;  F:  C if character read (non-blocking)
109+  ECBE C3 AF EC     Read_Char_NB:           JP      UART_RX
110+  ECC1
111+  ECC1              ; Print A to the screen as an ASCII character, preserving all registers.
112+  ECC1              print_a:
113+  ECC1 E5           UART_TX:	PUSH 	HL
114+  ECC2 D5           			PUSH 	DE
115+  ECC3 C5           			PUSH	BC						; Stack BC
116+  ECC4 F5           			PUSH	AF 						; Stack AF
117+  ECC5 06 58        			LD	B,low  UART_TX_WAIT			; Set CB to the transmit timeout
118+  ECC7 0E 02        			LD	C,high UART_TX_WAIT
119+  ECC9 DB BD        1:			IN	A,(uart_LSR)			; Get the line status register
120+  ECCB E6 60        			AND 	0x60					; Check for TX empty
121+  ECCD 20 0B        			JR	NZ,2F						; If set, then TX is empty, goto transmit
122+  ECCF 10 F8        			DJNZ	1B
122+  ECD1 0D             DEC	C
122+  ECD2 20 F5          JR NZ,1B		; Otherwise loop
123+  ECD4 F1           			POP	AF							; We've timed out at this point so
124+  ECD5 B7           			OR	A							; Clear the carry flag and preserve A
125+  ECD6 C1           			POP	BC							; Restore the stack
126+  ECD7 D1           			POP DE
127+  ECD8 E1           			POP	HL
128+  ECD9 C9           			RET
129+  ECDA F1           2:			POP	AF							; Good to send at this point, so
130+  ECDB D3 B8        			OUT	(uart_tx_rx),A			; Write the character to the UART transmit buffer
131+  ECDD CD E5 EC     			call	delay2
132+  ECE0 C1           			POP	BC							; Restore the stack
133+  ECE1 D1           			POP DE
134+  ECE2 E1           			POP	HL
135+  ECE3 37           			SCF								; Set the carry flag
136+  ECE4 C9           			RET
137+  ECE5              ;******************************************************************
138+  ECE5              ; This routine delay 746us
139+  ECE5              delay2:
140+  ECE5 F5           			PUSH   AF
141+  ECE6 3E FF        			LD     A, 0xFF
142+  ECE8 3D           delay2loop: DEC    A
143+  ECE9 C2 E8 EC     			JP     NZ, delay2loop  ; JUMP TO DELAYLOOP2 IF A <> 0.
144+  ECEC F1           			POP    AF
145+  ECED C9           			RET
146+  ECEE
147+  ECEE              ;    push af                         ; Store A for a bit
148+  ECEE              ;print_a1:
149+  ECEE              ;    in a,(uart_LSR)                 ; check UART is ready to send.
150+  ECEE              ;    bit 5,a                         ; zero flag set to true if bit 5 is 0
151+  ECEE              ;    jp z, print_a1                  ; non-zero = ready for next char.;
152+  ECEE
153+  ECEE              ;    pop af                          ; UART IS READY, GET OLD "A" BACK
154+  ECEE              ;    out (uart_tx_rx),a              ; AND SEND IT OUT
155+  ECEE              ;	ret
156+  ECEE
157+  ECEE              newline:
158+  ECEE 3E 0D        	ld a,13
159+  ECF0 CD C1 EC     	call print_a
160+  ECF3 3E 0A        	ld a,10
161+  ECF5 CD C1 EC     	call print_a
162+  ECF8 C9           	ret
163+  ECF9
164+  ECF9              space:
165+  ECF9 3E 20        	ld a,32
166+  ECFB CD C1 EC     	call print_a
167+  ECFE C9           	ret
168+  ECFF
169+  ECFF              ; To receive a char over Serial we need to check if there is one. If not we return 0.
170+  ECFF              ; If there is, we get it and return it (in a).
171+  ECFF              char_in:
172+  ECFF DB BD        	in a,(uart_LSR)			; get status from Line Status Register
173+  ED01 CB 47        	bit 0,a					; zero flag set to true if bit 0 is 0 (bit 0 = Receive Data Ready)
174+  ED03              							; "logic 0 = no data in receive holding register."
175+  ED03 CA 09 ED     	jp z,char_in1    		; zero = no char received
176+  ED06 DB B8        	in a,(uart_tx_rx)		; Get the incoming char
177+  ED08 C9           	ret						; Return it in A
178+  ED09              char_in1:
179+  ED09 3E 00        	ld a,0					; Return a zero in A
180+  ED0B C9           	ret
181+  ED0C
182+  ED0C              char_available:
183+  ED0C DB BD        	in a,(uart_LSR)			; get status from Line Status Register
184+  ED0E CB 47        	bit 0,a					; zero flag set to true if bit 0 is 0 (bit 0 = Receive Data Ready)
185+  ED10              							; "logic 0 = no data in receive holding register."
186+  ED10 CA 16 ED     	jp z,char_available1	; zero = no char received
187+  ED13 3E FF        	ld a, $FF		        ; return true
188+  ED15 C9           	ret						; in A
189+  ED16              char_available1:
190+  ED16 3E 00        	ld a,0					; Return a zero in A
191+  ED18 C9           	ret
192+  ED19
193+  ED19
194+  ED19              long_pause:
195+  ED19 01 E8 FD     	ld bc,65000
196+  ED1C 18 08            jr pause0
197+  ED1E              medium_pause:
198+  ED1E 01 C8 AF     	ld bc,45000
199+  ED21 18 03            jr pause0
200+  ED23              short_pause:
201+  ED23 01 64 00     	ld bc,100
202+  ED26              pause0:
203+  ED26 0B           	dec bc
204+  ED27 78           	ld a,b
205+  ED28 B1           	or c
206+  ED29 C2 26 ED     	jp nz,pause0
207+  ED2C C9           	ret
208+  ED2D
209+  ED2D              disk_toggle:
210+  ED2D DB BC        	in a, (uart_MCR)
211+  ED2F E6 04        	and %00000100
212+  ED31 28 07        	jr z, disk_on
213+  ED33              	; fall through to...
214+  ED33              disk_off:
215+  ED33               	; disk light off
216+  ED33 DB BC        	in a, (uart_MCR)
217+  ED35 E6 FB        	and %11111011
218+  ED37 D3 BC        	out (uart_MCR), a
219+  ED39 C9           	ret
220+  ED3A
221+  ED3A              disk_on:
222+  ED3A              	; disk light on
223+  ED3A DB BC        	in a, (uart_MCR)
224+  ED3C F6 04        	or %00000100
225+  ED3E D3 BC        	out (uart_MCR), a
226+  ED40 C9           	ret
227+  ED41
228+  ED41              user_on:
229+  ED41              	; user light on
230+  ED41 DB BC        	in a, (uart_MCR)
231+  ED43 F6 01        	or %00000001
232+  ED45 D3 BC        	out (uart_MCR), a
233+  ED47 C9           	ret
234+  ED48
235+  ED48              user_toggle:
236+  ED48              	; user1 light invert
237+  ED48 DB BC        	in a, (uart_MCR)
238+  ED4A E6 01        	and %00000001
239+  ED4C 28 F3        	jr z, user_on
240+  ED4E              	; fall through to...
241+  ED4E              user_off:
242+  ED4E               	; user light off
243+  ED4E DB BC        	in a, (uart_MCR)
244+  ED50 E6 FE        	and %11111110
245+  ED52 D3 BC        	out (uart_MCR), a
246+  ED54 C9           	ret
247+  ED55
248+  ED55              rom_toggle:
249+  ED55 DB BC        	in a, (uart_MCR)
250+  ED57 E6 08        	and %00001000
251+  ED59 28 07        	jr z, rom_off
252+  ED5B              	; fall through to...
253+  ED5B              rom_on:
254+  ED5B              	; rom light on
255+  ED5B DB BC        	in a, (uart_MCR)
256+  ED5D E6 F7        	and %11110111
257+  ED5F D3 BC        	out (uart_MCR), a
258+  ED61 C9           	ret
259+  ED62
260+  ED62              rom_off:
261+  ED62              	; rom light off
262+  ED62 DB BC        	in a, (uart_MCR)
263+  ED64 F6 08        	or %00001000
264+  ED66 D3 BC        	out (uart_MCR), a
265+  ED68 C9           	ret
266+  ED69
267+  ED69              	include "port_numbers.asm"
# file opened: port_numbers.asm
  1++ ED69              ; port_numbers.asm
  2++ ED69
  3++ ED69              ; Here are the port numbers for various UART registers:
  4++ ED69              uart_tx_rx 		equ   0xB8   ; 	8
  5++ ED69              uart_IER 		equ   0xB9   ; 	9
  6++ ED69              uart_ISR 		equ   0xBA   ;  10  ; Also known as FCR
  7++ ED69              uart_LCR 		equ   0xBB   ;  11
  8++ ED69              uart_MCR 		equ   0xBC   ;  12  ; modem control reg
  9++ ED69              uart_LSR 		equ   0xBD   ;  13
 10++ ED69              uart_MSR 		equ   0xBE   ;  14
 11++ ED69              uart_scratch 	equ   0xBF   ;  15
 12++ ED69
 13++ ED69              PIO_A	equ	0xA8		; CA80 user 8255 base address 	  (port A)
 14++ ED69              PIO_B	equ	0xA9		; CA80 user 8255 base address + 1 (port B)
 15++ ED69              PIO_C	equ	0xAA		; CA80 user 8255 base address + 2 (fport C)
 16++ ED69              PIO_M	equ	0xAB		; CA80 user 8255 control register
 17++ ED69
# file closed: port_numbers.asm
268+  ED69
# file closed: uart.asm
124   ED69                  include "message.asm"
# file opened: message.asm
  1+  ED69              ; message
  2+  ED69              message:
  3+  ED69 E3           	ex (sp), hl                   ; top of stack is now mangled, but hl is pointing to our message
  4+  ED6A F5           	push	af
  5+  ED6B C5           	push	bc
  6+  ED6C D5           	push	de
  7+  ED6D
  8+  ED6D              message_loop_001:
  9+  ED6D 7E           	ld a, (hl)
 10+  ED6E FE 00        	cp 0
 11+  ED70 28 06        	jr z, message_complete_001
 12+  ED72 23           	inc hl
 13+  ED73 CD C1 EC     	call print_a                  ; print a character (Mangles 2 items below top of stack)
 14+  ED76 18 F5        	jr message_loop_001               ; Loop until done
 15+  ED78
 16+  ED78              message_complete_001:
 17+  ED78 D1           	pop de
 18+  ED79 C1           	pop bc
 19+  ED7A F1           	pop af
 20+  ED7B 23           	inc hl
 21+  ED7C E3           	ex (sp), hl
 22+  ED7D C9           	ret
 23+  ED7E
 24+  ED7E
 25+  ED7E              ; -------------------------------------------------------------------------------------------------
 26+  ED7E
 27+  ED7E              ;message:
 28+  ED7E              ;	; Use this handy helper function to display an inline message easily.
 29+  ED7E              ;	; It preserves all registers (which was tricky to do).
 30+  ED7E              ;	; This expects to be called from code where the message follows the "call debug" in-line, like this:
 31+  ED7E              ;	;
 32+  ED7E              ;	; ld a, 10 ; (or whatever code you like)
 33+  ED7E              ;	; call message
 34+  ED7E              ;	; db "my message", 0
 35+  ED7E              ;	; ld b, 10 ; (or whatever code you like)
 36+  ED7E              ;	;
 37+  ED7E              ;	; When we return we make sure sp is pointing to the next line of code after the message.
 38+  ED7E              ;
 39+  ED7E              ;							; sp -> ret-addr
 40+  ED7E              ;
 41+  ED7E              ;	push af					; We have stored af
 42+  ED7E              ;	push af					; We do this 3 times
 43+  ED7E              ;	push af					; to allow spare stack space.
 44+  ED7E              ;							; sp -> AF, AF, AF, ret-addr
 45+  ED7E              ;	push bc					; sp -> BC, AF, AF, AF, ret-addr
 46+  ED7E              ;	push de					; sp -> DE, BC, AF, AF, AF, ret-addr
 47+  ED7E              ;	push hl					; sp -> HL, DE, BC, AF, AF, AF, ret-addr
 48+  ED7E              ;
 49+  ED7E              ;	inc sp
 50+  ED7E              ;	inc sp					; adjust the stack to overlook the stored afx3, BC, DE & HL
 51+  ED7E              ;							; HL, sp -> DE, BC, AF, AF, AF, ret-addr
 52+  ED7E              ;	inc sp
 53+  ED7E              ;	inc sp					; HL, DE, sp -> BC, AF, AF, AF, ret-addr
 54+  ED7E              ;
 55+  ED7E              ;	inc sp
 56+  ED7E              ;	inc sp					; HL, DE, BC, sp -> AF, AF, AF, ret-addr
 57+  ED7E              ;
 58+  ED7E              ;	inc sp
 59+  ED7E              ;	inc sp
 60+  ED7E              ;
 61+  ED7E              ;	inc sp
 62+  ED7E              ;	inc sp
 63+  ED7E              ;
 64+  ED7E              ;	inc sp
 65+  ED7E              ;	inc sp					; HL, DE, BC, AF, AF, AF, sp -> ret-addr
 66+  ED7E              ;
 67+  ED7E              ;	ex (sp), hl				; top of stack is now mangled, but hl is pointing to our message
 68+  ED7E              ;							; HL, DE, BC, AF, AF, AF, sp -> HL
 69+  ED7E              ;
 70+  ED7E              ;message_loop:
 71+  ED7E              ;	ld a, (hl)
 72+  ED7E              ;	cp 0
 73+  ED7E              ;	jr z,message_complete
 74+  ED7E              ;	inc hl
 75+  ED7E              ;	call print_a			; print a character (Mangles 2 items below top of stack)
 76+  ED7E              ;	jr message_loop			; Loop until done
 77+  ED7E              ;							; HL, DE, BC, AF, XX, XX, sp -> HL
 78+  ED7E              ;
 79+  ED7E              ;message_complete:
 80+  ED7E              ;	inc hl
 81+  ED7E              ;	ex (sp), hl				; restore top of stack, after we have incremented it so it points to the subsequent instruction
 82+  ED7E              ;							; HL, DE, BC, AF, XX, XX, sp -> new-ret-addr
 83+  ED7E              ;	dec sp
 84+  ED7E              ;	dec sp
 85+  ED7E              ;
 86+  ED7E              ;	dec sp
 87+  ED7E              ;	dec sp
 88+  ED7E              ;
 89+  ED7E              ;	dec sp
 90+  ED7E              ;	dec sp					; adjust stack because of our pushed "af"
 91+  ED7E              ;							; HL, DE, BC, sp -> AF, XX, XX, new-ret-addr
 92+  ED7E              ;	dec sp
 93+  ED7E              ;	dec sp					; adjust stack because of our pushed "BC"
 94+  ED7E              ;							; HL, DE, sp -> BC, AF, XX, XX, new-ret-addr
 95+  ED7E              ;	dec sp
 96+  ED7E              ;	dec sp					; adjust stack because of our pushed "DE"
 97+  ED7E              ;							; HL, sp -> DE, BC, AF, XX, XX, new-ret-addr
 98+  ED7E              ;	dec sp
 99+  ED7E              ;	dec sp					; adjust stack because of our pushed "HL"
100+  ED7E              ;							; sp -> HL, DE, BC, AF, XX, XX, new-ret-addr
101+  ED7E              ;
102+  ED7E              ;	pop hl					; HL is restored
103+  ED7E              ;							; sp -> DE, BC, AF, XX, XX, new-ret-addr
104+  ED7E              ;	pop de					; DE is restored
105+  ED7E              ;							; sp -> BC, AF, XX, XX, new-ret-addr
106+  ED7E              ;	pop bc					; BC is restored
107+  ED7E              ;							; sp -> AF, XX, XX, new-ret-addr
108+  ED7E              ;	pop af					; we have restored af
109+  ED7E              ;							; sp -> XX, XX, new-ret-addr
110+  ED7E              ;
111+  ED7E              ;	inc sp
112+  ED7E              ;	inc sp
113+  ED7E              ;	inc sp
114+  ED7E              ;	inc sp
115+  ED7E              ;							; sp -> new-ret-addr
116+  ED7E              ;
117+  ED7E              ;	ret						; return to the instruction after the message
118+  ED7E
119+  ED7E              show_hl_as_hex:
120+  ED7E 7C               ld a, h
121+  ED7F CD 87 ED         call show_a_as_hex
122+  ED82 7D               ld a, l
123+  ED83 CD 87 ED         call show_a_as_hex
124+  ED86 C9               ret
125+  ED87
126+  ED87              show_a_as_hex:
127+  ED87 F5               push af
128+  ED88 CB 3F            srl a
129+  ED8A CB 3F            srl a
130+  ED8C CB 3F            srl a
131+  ED8E CB 3F            srl a
132+  ED90 C6 30            add a,'0'
133+  ED92 FE 3A        	cp ':'
134+  ED94 38 02        	jr c, show_a_as_hex1
135+  ED96 C6 07        	add a, 7
136+  ED98              show_a_as_hex1:
137+  ED98 CD C1 EC         call print_a
138+  ED9B F1               pop af
139+  ED9C E6 0F            and %00001111
140+  ED9E C6 30            add a,'0'
141+  EDA0 FE 3A        	cp ':'
142+  EDA2 38 02        	jr c, show_a_as_hex2
143+  EDA4 C6 07        	add a, 7
144+  EDA6              show_a_as_hex2:
145+  EDA6 CD C1 EC         call print_a
146+  EDA9 C9               ret
147+  EDAA
148+  EDAA              ;---------------------------------------------------
149+  EDAA              ; show_all shows all the CPU registers!
150+  EDAA
151+  EDAA              show_all:
152+  EDAA ED 73 09 EE  	ld (store_sp), sp
153+  EDAE F5           	push af
154+  EDAF E5           	push hl
155+  EDB0 D5           	push de
156+  EDB1 C5           	push bc
157+  EDB2
158+  EDB2 CD 69 ED     	call message
159+  EDB5 41 3D 00     	db 'A=',0
160+  EDB8 CD 87 ED     	call show_a_as_hex
161+  EDBB
162+  EDBB E1           	pop hl
163+  EDBC CD 69 ED     	call message
164+  EDBF 2C 20 42 43  	db ', BC=',0
164+  EDC3 3D 00
165+  EDC5 CD 7E ED     	call show_hl_as_hex
166+  EDC8 C5           	push bc
167+  EDC9
168+  EDC9 C1           	pop bc
169+  EDCA E1           	pop hl
170+  EDCB CD 69 ED     	call message
171+  EDCE 2C 20 44 45  	db ', DE=',0
171+  EDD2 3D 00
172+  EDD4 CD 7E ED     	call show_hl_as_hex
173+  EDD7 D5           	push de
174+  EDD8 C5           	push bc
175+  EDD9
176+  EDD9 C1           	pop bc
177+  EDDA D1           	pop de
178+  EDDB E1           	pop hl
179+  EDDC CD 69 ED     	call message
180+  EDDF 2C 20 48 4C  	db ', HL=',0
180+  EDE3 3D 00
181+  EDE5 CD 7E ED     	call show_hl_as_hex
182+  EDE8 E5           	push hl
183+  EDE9 D5           	push de
184+  EDEA C5           	push bc
185+  EDEB
186+  EDEB CD 69 ED     	call message
187+  EDEE 2C 20 53 50  	db ', SP=',0
187+  EDF2 3D 00
188+  EDF4 2A 09 EE     	ld hl, (store_sp)
189+  EDF7 CD 7E ED     	call show_hl_as_hex
190+  EDFA
191+  EDFA 3E 0D        	ld a, 13
192+  EDFC CD C1 EC     	call print_a
193+  EDFF 3E 0A        	ld a, 10
194+  EE01 CD C1 EC     	call print_a
195+  EE04
196+  EE04 C1           	pop bc
197+  EE05 D1           	pop de
198+  EE06 E1           	pop hl
199+  EE07 F1           	pop af
200+  EE08 C9           	ret
201+  EE09
202+  EE09              store_sp:
203+  EE09 00 00        	 ds 2
# file closed: message.asm
125   EE0B                  include "memorystick.asm"
# file opened: memorystick.asm
  1+  EE0B              ; memorystick.asm
  2+  EE0B
  3+  EE0B              store_de:
  4+  EE0B 00 00            dw 0
  5+  EE0D              store_a:
  6+  EE0D 00               db 0
  7+  EE0E              ;-----------------------------------------------------------------
  8+  EE0E              ; For DIRectory listing, the filename is passed in the filename_buffer.
  9+  EE0E              ; DE -> DMA AREA
 10+  EE0E              ; a = Current User
 11+  EE0E              ; It will be something like A/ffffffff.xxx
 12+  EE0E              ; A result gets put into the area pointed to by DE, normally the DMA area, in 8.3 format
 13+  EE0E              dir:
 14+  EE0E ED 53 0B EE      ld (store_de), de
 15+  EE12 32 0D EE         ld (store_a), a
 16+  EE15
 17+  EE15 CD 3A ED         call disk_on
 18+  EE18
 19+  EE18 21 88 F4         ld hl, CPM_FOLDER_NAME                    ; Start at /CPM
 20+  EE1B CD 82 F3         call open_file
 21+  EE1E 21 95 F4         ld hl, CPM_DISKS_NAME                    ; Then DISKS
 22+  EE21 CD 82 F3         call open_file
 23+  EE24
 24+  EE24 21 EB FF         ld hl, filename_buffer
 25+  EE27 7E               ld a, (hl)
 26+  EE28 21 E9 FF         ld hl, DRIVE_NAME                       ; Move to "A" .. "P" for required disk
 27+  EE2B 77               ld (hl), a
 28+  EE2C 23               inc hl
 29+  EE2D 36 00            ld (hl), 0
 30+  EE2F 2B               dec hl
 31+  EE30 CD 82 F3         call open_file
 32+  EE33
 33+  EE33                  ; Now user number (if greater than 0)
 34+  EE33 3A 0D EE         ld a, (store_a)
 35+  EE36 FE 00            cp 0
 36+  EE38 28 0E            jr z, ignore_user
 37+  EE3A
 38+  EE3A CD DC F1         call convert_user_number_to_folder_name
 39+  EE3D 21 E9 FF         ld hl, DRIVE_NAME                   ; Move to "1" .. "F" for required user
 40+  EE40 77               ld (hl), a
 41+  EE41 23               inc hl
 42+  EE42 36 00            ld (hl), 0
 43+  EE44 2B               dec hl
 44+  EE45 CD 82 F3         call open_file
 45+  EE48
 46+  EE48              ignore_user:
 47+  EE48 21 86 F4         ld hl, STAR_DOT_STAR                    ; Specify search pattern "*"
 48+  EE4B CD 82 F3         call open_file
 49+  EE4E
 50+  EE4E                  ; Read a file if there is something to read
 51+  EE4E              dir_loop:
 52+  EE4E                  ; at this point DE is in store_de, containing address of dma-area
 53+  EE4E FE 1D            cp USB_INT_DISK_READ
 54+  EE50 28 2E            jr z, dir_loop_good
 55+  EE52
 56+  EE52 FE 42            cp ERR_MISS_FILE    ; This is what you normally get at the end of a dir listing
 57+  EE54 28 24            jr z, dir_no_file
 58+  EE56
 59+  EE56 FE A1            cp ERR_BPB_ERROR    ; This means a disk format error
 60+  EE58 20 20            jr nz, dir_no_file
 61+  EE5A
 62+  EE5A CD 69 ED         call message
 63+  EE5D 55 53 42 20      db 'USB Drive ERROR: FAT only!',13,10,0
 63+  EE61 44 72 69 76
 63+  EE65 65 20 45 52
 63+  EE69 52 4F 52 3A
 63+  EE6D 20 46 41 54
 63+  EE71 20 6F 6E 6C
 63+  EE75 79 21 0D 0A
 63+  EE79 00
 64+  EE7A              dir_no_file:
 65+  EE7A CD 33 ED         call disk_off
 66+  EE7D 3E FF            ld a, 255
 67+  EE7F C9               ret
 68+  EE80
 69+  EE80              dir_loop_good:
 70+  EE80                  ; at this point DE is on stack, containing address of dma-area
 71+  EE80 3E 27            ld a, RD_USB_DATA0
 72+  EE82 CD 32 F4         call send_command_byte
 73+  EE85 CD 3B F4         call read_data_byte                 ; Find out how many bytes there are to read
 74+  EE88
 75+  EE88 CD 41 F4         call read_data_bytes_into_buffer    ; read them into disk_buffer
 76+  EE8B FE 20            cp 32                               ; Did we read at least 32 bytes?
 77+  EE8D 30 03            jr nc, good_length
 78+  EE8F C3 12 EF         jp dir_next
 79+  EE92
 80+  EE92              good_length:
 81+  EE92                  ; at this point DE is in store_de, containing address of dma-area
 82+  EE92                  ; Get the attributes for this entry. $02 = system, $04 = hidden, $10 = directory
 83+  EE92 CD 33 ED         call disk_off
 84+  EE95 3A D0 FF         ld a, (disk_buffer+11)
 85+  EE98 E6 16            and $16                         ; Check for hidden or system files, or directories
 86+  EE9A CA A0 EE         jp z, it_is_not_system
 87+  EE9D C3 12 EF         jp dir_next                     ; and skip accordingly.
 88+  EEA0
 89+  EEA0              it_is_not_system:
 90+  EEA0                  ; Does it match the search pattern?
 91+  EEA0 06 0B            ld b, 11
 92+  EEA2 21 C5 FF         ld hl, disk_buffer
 93+  EEA5 11 ED FF         ld de, filename_buffer+2
 94+  EEA8              matching_loop:
 95+  EEA8                  ; If the filename_buffer has a '.' then skip over it
 96+  EEA8                  ; and move disk_buffer to start of extension
 97+  EEA8 1A               ld a, (de)
 98+  EEA9 FE 2E            cp '.'
 99+  EEAB 20 06            jr nz, matching_loop1
100+  EEAD
101+  EEAD 13               inc de
102+  EEAE 21 CD FF         ld hl, disk_buffer+8
103+  EEB1 06 03            ld b, 3
104+  EEB3
105+  EEB3              matching_loop1
106+  EEB3 1A               ld a, (de)
107+  EEB4 FE 3F            cp '?'
108+  EEB6 28 05            jr z, matching_loop_good
109+  EEB8 BE               cp (hl)
110+  EEB9 28 02            jr z, matching_loop_good
111+  EEBB 18 55            jr dir_next
112+  EEBD
113+  EEBD              matching_loop_good:
114+  EEBD 13               inc de
115+  EEBE 23               inc hl
116+  EEBF 10 E7            djnz matching_loop
117+  EEC1
118+  EEC1                  ; Copy 11 byte filename + extension
119+  EEC1 01 0B 00         ld bc, 11
120+  EEC4 21 C5 FF         ld hl, disk_buffer
121+  EEC7 ED 5B 0B EE      ld de, (store_de)
122+  EECB
123+  EECB                  ; The Usernumber goes into the first byte of the FCB
124+  EECB 3A 0D EE         ld a, (store_a)
125+  EECE E6 0F            and %00001111
126+  EED0 12               ld (de), a                      ; Store user number in FCB result
127+  EED1 13               inc de
128+  EED2 ED B0            ldir                            ; Copy filename & extension
129+  EED4
130+  EED4                  ; Fill in a few more details. File size into normal place, plus random record info.
131+  EED4                  ; The filesize is a 32 bit number in FAT_DIR_INFO at loc $1C, 1D, 1E and 1F.
132+  EED4                  ; We want it in 128 byte sectors, so need to divide by 128.
133+  EED4 21 E1 FF         ld hl, disk_buffer+$1C
134+  EED7 5E               ld e, (hl)
135+  EED8 23               inc hl
136+  EED9 56               ld d, (hl)
137+  EEDA 23               inc hl
138+  EEDB 4E               ld c, (hl)
139+  EEDC 23               inc hl
140+  EEDD 46               ld b, (hl)                          ; BCDE has file size
141+  EEDE EB               ex de, hl                           ; 32-bit filesize now in BCHL
142+  EEDF
143+  EEDF                  ; Divide by 128
144+  EEDF CB 25            sla l                               ; Shift all left by 1 bit
145+  EEE1 CB 14            rl h
146+  EEE3 CB 11            rl c
147+  EEE5 CB 10            rl b
148+  EEE7
149+  EEE7 6C               ld l, h
150+  EEE8 61               ld h, c
151+  EEE9 48               ld c, b
152+  EEEA 06 00            ld b, 0                             ; We've shifted right 8 bits, so effectively divided by 128!
153+  EEEC
154+  EEEC ED 5B 0B EE      ld de, (store_de)
155+  EEF0
156+  EEF0 C5               push bc                             ; Store the size that is in bchl
157+  EEF1 E5               push hl
158+  EEF2 CD 8C F1         call set_random_pointer_in_fcb      ; store hl in FCB random pointer (bc is thrown away!)
159+  EEF5 E1               pop hl
160+  EEF6 C1               pop bc                              ; restore bchl
161+  EEF7
162+  EEF7 EB               ex de, hl                           ; hl = fcb, bcde = filesize
163+  EEF8 2A 0B EE         ld hl, (store_de)
164+  EEFB CD 9B F1         call set_file_size_in_fcb
165+  EEFE
166+  EEFE                  ; Clear all 16 disk allocation bytes. TODO: Actually, fill with sensible values
167+  EEFE ED 5B 0B EE      ld de, (store_de)
168+  EF02 21 10 00         ld hl, 16
169+  EF05 19               add hl, de
170+  EF06 EB               ex de, hl
171+  EF07 06 14            ld b, 16+4
172+  EF09 3E 00            ld a, 0
173+  EF0B              clear_allocation_loop:
174+  EF0B 12               ld (de), a
175+  EF0C 13               inc de
176+  EF0D 10 FC            djnz clear_allocation_loop
177+  EF0F              good_length1:
178+  EF0F 3E 00            ld a, 0                                 ; 0 = success
179+  EF11 C9               ret
180+  EF12
181+  EF12              dir_next:
182+  EF12 3E 33            ld a, FILE_ENUM_GO                      ; Go to next entry in the directory
183+  EF14 CD 32 F4         call send_command_byte
184+  EF17 CD 77 F4         call read_status_byte
185+  EF1A C3 4E EE         jp dir_loop
186+  EF1D
187+  EF1D              ;-----------------------------------------
188+  EF1D              ; Load bin File
189+  EF1D              ; The filename needs to be in the filename buffer.
190+  EF1D              ; The file must be in the /CPM folder.
191+  EF1D              ; DE points to the location to load it into.
192+  EF1D              ; The file is loaded into the workspace.
193+  EF1D              ; There is no check whether the file is too big!!!!
194+  EF1D              ; Returns zero flag set if success, zero flag cleared on file-not-found.
195+  EF1D
196+  EF1D              load_bin_file:
197+  EF1D D5               push de                             ; Store target location for later
198+  EF1E CD 3A ED         call disk_on
199+  EF21 CD A8 F2         call connect_to_disk
200+  EF24 CD D7 F2         call mount_disk
201+  EF27
202+  EF27 21 88 F4         ld hl, CPM_FOLDER_NAME              ; Start at /CPM
203+  EF2A CD 82 F3         call open_file
204+  EF2D
205+  EF2D 21 EB FF         ld hl, filename_buffer              ; Specify filename
206+  EF30 CD 82 F3         call open_file
207+  EF33
208+  EF33 28 2B            jr z, load_file_found
209+  EF35 CD 33 ED         call disk_off
210+  EF38 CD 69 ED         call message
211+  EF3B 46 69 6C 65      db 'File not found ',0
211+  EF3F 20 6E 6F 74
211+  EF43 20 66 6F 75
211+  EF47 6E 64 20 00
212+  EF4B 21 EB FF         ld hl, filename_buffer
213+  EF4E              load_file1:
214+  EF4E 7E               ld a, (hl)
215+  EF4F FE 00            cp 0
216+  EF51 28 06            jr z, load_file2
217+  EF53 CD C1 EC         call print_a
218+  EF56 23               inc hl
219+  EF57 18 F5            jr load_file1
220+  EF59              load_file2:
221+  EF59 CD EE EC         call newline
222+  EF5C D1               pop de                              ; Keep stack clear!
223+  EF5D F6 01            or 1                                ; Clear zero flag for failure
224+  EF5F C9               ret
225+  EF60              load_file_found:
226+  EF60 CD 33 ED         call disk_off
227+  EF63 3E 3A            ld a, BYTE_READ
228+  EF65 CD 32 F4         call send_command_byte
229+  EF68 3E FF            ld a, 255                           ; Request all of the file
230+  EF6A CD 16 F4         call send_data_byte
231+  EF6D 3E FF            ld a, 255                           ; Yes, all!
232+  EF6F CD 16 F4         call send_data_byte
233+  EF72
234+  EF72 3E 22            ld a, GET_STATUS
235+  EF74 CD 32 F4         call send_command_byte
236+  EF77 CD 3B F4         call read_data_byte
237+  EF7A E1               pop hl                              ; Get back the target address
238+  EF7B              load_loop1:
239+  EF7B FE 1D            cp USB_INT_DISK_READ
240+  EF7D 20 25            jr nz, load_finished
241+  EF7F
242+  EF7F E5               push hl
243+  EF80 CD 3A ED         call disk_on
244+  EF83 3E 27            ld a, RD_USB_DATA0
245+  EF85 CD 32 F4         call send_command_byte
246+  EF88 CD 3B F4         call read_data_byte
247+  EF8B E1               pop hl
248+  EF8C CD 44 F4         call read_data_bytes_into_hl        ; Read this block of data
249+  EF8F E5               push hl
250+  EF90 CD 33 ED         call disk_off
251+  EF93 3E 3B            ld a, BYTE_RD_GO
252+  EF95 CD 32 F4         call send_command_byte
253+  EF98 3E 22            ld a, GET_STATUS
254+  EF9A CD 32 F4         call send_command_byte
255+  EF9D CD 3B F4         call read_data_byte
256+  EFA0 E1               pop hl
257+  EFA1 C3 7B EF         jp load_loop1
258+  EFA4              load_finished:
259+  EFA4 E5               push hl
260+  EFA5 CD 95 F3         call close_file
261+  EFA8 E1               pop hl
262+  EFA9 BF               cp a                                ; set zero flag for success
263+  EFAA C9               ret
264+  EFAB
265+  EFAB              ; ---------------------------------
266+  EFAB              ; Directory info read.
267+  EFAB              ; Reads a directory entry (of the currently open file) into disk_buffer
268+  EFAB              ; Returns ZERO FLAG = set if ok
269+  EFAB              dir_info_read:
270+  EFAB 3E 37            ld a, DIR_INFO_READ
271+  EFAD CD 32 F4         call send_command_byte
272+  EFB0 3E FF            ld a, $FF                           ; Current open file
273+  EFB2 CD 16 F4         call send_data_byte
274+  EFB5
275+  EFB5 CD 77 F4         call read_status_byte
276+  EFB8 FE 14            cp USB_INT_SUCCESS
277+  EFBA C0               ret nz
278+  EFBB
279+  EFBB 3E 27            ld a, RD_USB_DATA0
280+  EFBD CD 32 F4         call send_command_byte
281+  EFC0 CD 3B F4         call read_data_byte                 ; Find out how many bytes there are to read
282+  EFC3
283+  EFC3 CD 41 F4         call read_data_bytes_into_buffer
284+  EFC6 FE 20            cp $20                              ; Must have read 32 bytes
285+  EFC8 C0               ret nz                              ; or else it is an error
286+  EFC9              ;     call message
287+  EFC9              ;     db 'Read this many bytes: ',0
288+  EFC9              ;     call show_a_as_hex
289+  EFC9              ;     call newline
290+  EFC9
291+  EFC9              ;     ld b, $20
292+  EFC9              ;     ld hl, disk_buffer
293+  EFC9              ; dir_info_read1:
294+  EFC9              ;     ld a, (hl)
295+  EFC9              ;     push hl
296+  EFC9              ;     push bc
297+  EFC9              ;     call show_a_as_hex
298+  EFC9              ;     ld a, ','
299+  EFC9              ;     call print_a
300+  EFC9              ;     pop bc
301+  EFC9              ;     pop hl
302+  EFC9              ;     inc hl
303+  EFC9              ;     djnz dir_info_read1
304+  EFC9              ;     call newline
305+  EFC9
306+  EFC9 BF               cp a                                ; set zero flag for success
307+  EFCA C9               ret
308+  EFCB
309+  EFCB              ; DIR_INFO_WRITE
310+  EFCB              ; writes a dir_info block from disk_buffer to the USB drive
311+  EFCB              ; for the currently open file
312+  EFCB              dir_info_write:
313+  EFCB 3E 37            ld a, DIR_INFO_READ
314+  EFCD CD 32 F4         call send_command_byte
315+  EFD0 3E FF            ld a, $FF                           ; Current open file
316+  EFD2 CD 16 F4         call send_data_byte
317+  EFD5
318+  EFD5 CD 77 F4         call read_status_byte
319+  EFD8                  ;call report_on_status
320+  EFD8 FE 14            cp USB_INT_SUCCESS
321+  EFDA 20 28            jr nz, dir_info_write2
322+  EFDC
323+  EFDC 3E 2E            ld a, WR_OFS_DATA
324+  EFDE CD 32 F4         call send_command_byte
325+  EFE1 3E 00            ld a, 0
326+  EFE3 CD 16 F4         call send_data_byte
327+  EFE6 3E 20            ld a, $20
328+  EFE8 CD 16 F4         call send_data_byte
329+  EFEB 06 20            ld b, $20
330+  EFED 21 C5 FF         ld hl, disk_buffer
331+  EFF0              dir_info_write1:
332+  EFF0 7E               ld a, (hl)
333+  EFF1 E5               push hl
334+  EFF2 C5               push bc
335+  EFF3 CD 16 F4         call send_data_byte
336+  EFF6 C1               pop bc
337+  EFF7 E1               pop hl
338+  EFF8 23               inc hl
339+  EFF9 10 F5            djnz dir_info_write1
340+  EFFB
341+  EFFB 3E 38            ld a, DIR_INFO_SAVE
342+  EFFD CD 32 F4         call send_command_byte
343+  F000 CD 3B F4         call read_data_byte
344+  F003                  ;call report_on_status
345+  F003 C9               ret
346+  F004
347+  F004              dir_info_write2:
348+  F004 C9               ret
349+  F005
350+  F005              ;----------------------------------
351+  F005              ; WRITE TO FILE
352+  F005
353+  F005              write_to_file:
354+  F005                  ; writes 128 bytes from current location pointed to by DE, to the open file
355+  F005 D5               push de
356+  F006 3E 3C            ld a, BYTE_WRITE
357+  F008 CD 32 F4         call send_command_byte
358+  F00B
359+  F00B                  ; Send number of bytes we are about to write, as 16 bit number, low first
360+  F00B 3E 80            ld a, 128
361+  F00D CD 16 F4         call send_data_byte
362+  F010 3E 00            ld a, 0
363+  F012 CD 16 F4         call send_data_byte
364+  F015
365+  F015 E1               pop hl                              ; hl -> the data
366+  F016
367+  F016              write_loop
368+  F016 CD 77 F4         call read_status_byte
369+  F019 FE 1E            cp USB_INT_DISK_WRITE
370+  F01B 20 24            jr nz, write_finished
371+  F01D
372+  F01D E5               push hl
373+  F01E                  ; Ask if we can send some bytes
374+  F01E 3E 2D            ld a, WR_REQ_DATA
375+  F020 CD 32 F4         call send_command_byte
376+  F023 CD 3B F4         call read_data_byte
377+  F026 E1               pop hl
378+  F027 FE 00            cp 0
379+  F029 28 16            jr z, write_finished
380+  F02B
381+  F02B                  ; push hl
382+  F02B                  ; push af
383+  F02B                  ; call message
384+  F02B                  ; db 'Bytes to send: ',0
385+  F02B                  ; pop af
386+  F02B                  ; push af
387+  F02B                  ; call show_a_as_hex
388+  F02B                  ; call newline
389+  F02B                  ; pop af
390+  F02B                  ; pop hl
391+  F02B
392+  F02B 47               ld b, a
393+  F02C              block_loop:
394+  F02C 7E               ld a, (hl)
395+  F02D E5               push hl
396+  F02E C5               push bc
397+  F02F CD 16 F4         call send_data_byte
398+  F032 C1               pop bc
399+  F033 E1               pop hl
400+  F034 23               inc hl
401+  F035 10 F5            djnz block_loop
402+  F037
403+  F037 E5               push hl
404+  F038 3E 3D            ld a, BYTE_WR_GO
405+  F03A CD 32 F4         call send_command_byte
406+  F03D E1               pop hl
407+  F03E C3 16 F0         jp write_loop
408+  F041
409+  F041              write_finished:
410+  F041 C9               ret
411+  F042
412+  F042
413+  F042              ;-------------------------------------------
414+  F042              ; ERASE FILE
415+  F042
416+  F042              erase_file:
417+  F042 3E 2F            ld a, SET_FILE_NAME
418+  F044 CD 32 F4         call send_command_byte
419+  F047 21 EB FF         ld hl, filename_buffer
420+  F04A CD 1C F4         call send_data_string
421+  F04D 3E 35            ld a, FILE_ERASE
422+  F04F CD 32 F4         call send_command_byte
423+  F052 CD 77 F4         call read_status_byte
424+  F055 C9               ret
425+  F056
426+  F056              show_filename_buffer:
427+  F056 21 EB FF         ld hl, filename_buffer
428+  F059 06 14            ld b, 20
429+  F05B              show_filename_buffer1:
430+  F05B 7E               ld a, (hl)
431+  F05C FE 20            cp 32
432+  F05E 38 0A            jr c, control_char
433+  F060              show_filename_buffer2
434+  F060 CD C1 EC         call print_a
435+  F063 23               inc hl
436+  F064 10 F5            djnz show_filename_buffer1
437+  F066 CD EE EC         call newline
438+  F069 C9               ret
439+  F06A
440+  F06A              control_char:
441+  F06A C6 40            add a, 64
442+  F06C 4F               ld c, a
443+  F06D 3E 5E            ld a, '^'
444+  F06F CD C1 EC         call print_a
445+  F072 79               ld a, c
446+  F073 18 EB            jr show_filename_buffer2
447+  F075
448+  F075              check_tbasic_structure:
449+  F075                  ; Check that there is a /TBASIC folder
450+  F075                  ; and if not, make it!
451+  F075 CD 69 ED         call message
452+  F078 43 68 65 63      db 'Checking /TBASIC',13,10,0
452+  F07C 6B 69 6E 67
452+  F080 20 2F 54 42
452+  F084 41 53 49 43
452+  F088 0D 0A 00
453+  F08B
454+  F08B 21 8D F4         ld hl, TINY_BASIC_FOLDER_NAME
455+  F08E CD 0A F4         call copy_filename_to_buffer
456+  F091 21 EB FF         ld hl, filename_buffer
457+  F094 CD 82 F3         call open_file
458+  F097 FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
459+  F099 C8               ret z                               ; If found, job done.
460+  F09A CD A3 F3         call create_directory
461+  F09D C8               ret z                               ; If created ok, job done.
462+  F09E CD 69 ED         call message
463+  F0A1 45 52 52 4F      db 'ERROR creating Tiny Basic folder!',13,10,0
463+  F0A5 52 20 63 72
463+  F0A9 65 61 74 69
463+  F0AD 6E 67 20 54
463+  F0B1 69 6E 79 20
463+  F0B5 42 61 73 69
463+  F0B9 63 20 66 6F
463+  F0BD 6C 64 65 72
463+  F0C1 21 0D 0A 00
464+  F0C5 C9               ret
465+  F0C6
466+  F0C6              check_cpmdisks_structure:
467+  F0C6                  ; Check that we have a disk structure like this:
468+  F0C6                  ; /CPMDISKS
469+  F0C6                  ;          /A
470+  F0C6                  ;          /B
471+  F0C6                  ;          /C
472+  F0C6                  ;          :
473+  F0C6                  ;          /P
474+  F0C6
475+  F0C6                  ; Loop over A..P
476+  F0C6 06 10            ld b, 16
477+  F0C8              check_cpmdisk_loop:
478+  F0C8 C5               push bc
479+  F0C9                  ; Go to /CPM
480+  F0C9 CD 69 ED         call message
481+  F0CC 43 68 65 63      db 'Checking /CPM',13,10,0
481+  F0D0 6B 69 6E 67
481+  F0D4 20 2F 43 50
481+  F0D8 4D 0D 0A 00
482+  F0DC
483+  F0DC 21 88 F4         ld hl, CPM_FOLDER_NAME
484+  F0DF CD 0A F4         call copy_filename_to_buffer
485+  F0E2 21 EB FF         ld hl, filename_buffer
486+  F0E5 CD 82 F3         call open_file
487+  F0E8 FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
488+  F0EA 20 42            jr nz, check_cpmdisks_structure2
489+  F0EC
490+  F0EC CD 69 ED         call message
491+  F0EF 43 68 65 63      db 'Checking /CPM/DISKS',13,10,0
491+  F0F3 6B 69 6E 67
491+  F0F7 20 2F 43 50
491+  F0FB 4D 2F 44 49
491+  F0FF 53 4B 53 0D
491+  F103 0A 00
492+  F105 21 95 F4         ld hl, CPM_DISKS_NAME
493+  F108 CD 0A F4         call copy_filename_to_buffer
494+  F10B 21 EB FF         ld hl, filename_buffer
495+  F10E CD 82 F3         call open_file
496+  F111 FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
497+  F113 20 19            jr nz, check_cpmdisks_structure2
498+  F115
499+  F115 C1               pop bc
500+  F116 C5               push bc
501+  F117 78               ld a, b
502+  F118 C6 40            add a, 'A'-1
503+  F11A 32 EB FF         ld (filename_buffer), a
504+  F11D 3E 00            ld a, 0
505+  F11F 32 EC FF         ld (filename_buffer+1),a
506+  F122 21 EB FF         ld hl, filename_buffer
507+  F125 CD 82 F3         call open_file
508+  F128 FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
509+  F12A 20 0B            jr nz, check_cpmdisks_structure3
510+  F12C
511+  F12C C1               pop bc                              ; Let's say if we find disk "P" then they are all there!!!
512+  F12D                  ;djnz check_cpmdisk_loop
513+  F12D
514+  F12D C9               ret
515+  F12E
516+  F12E              check_cpmdisks_structure2:
517+  F12E C1               pop bc
518+  F12F                  ; Try to create the missing folder
519+  F12F                  ;ld hl, CPMDISKS_NAME
520+  F12F                  ;call copy_filename_to_buffer
521+  F12F CD A3 F3         call create_directory
522+  F132 20 0D            jr nz, check_cpmdisks_structure_fail
523+  F134
524+  F134                  ; Start all over again
525+  F134 C3 C6 F0         jp check_cpmdisks_structure
526+  F137
527+  F137              check_cpmdisks_structure3:
528+  F137 CD A3 F3         call create_directory
529+  F13A 20 04            jr nz, check_cpmdisks_subdir_fail
530+  F13C C1               pop bc                                          ; All good, so do the next subdir
531+  F13D C3 C8 F0         jp check_cpmdisk_loop
532+  F140
533+  F140              check_cpmdisks_subdir_fail:
534+  F140 C1               pop bc
535+  F141                  ; Continue through to the next bit...
536+  F141              check_cpmdisks_structure_fail:
537+  F141 CD 69 ED         call message
538+  F144 45 52 52 4F      db 'ERROR creating CP/M disks!',13,10,0
538+  F148 52 20 63 72
538+  F14C 65 61 74 69
538+  F150 6E 67 20 43
538+  F154 50 2F 4D 20
538+  F158 64 69 73 6B
538+  F15C 73 21 0D 0A
538+  F160 00
539+  F161 C9               ret
540+  F162
541+  F162              move_to_file_pointer:
542+  F162                  ; Set the BYTE_LOCATE file position in the currently open file.
543+  F162                  ; Value is passed in bcde.
544+  F162 C5               push bc
545+  F163 D5               push de
546+  F164 3E 39            ld a, BYTE_LOCATE
547+  F166 CD 32 F4         call send_command_byte
548+  F169 D1               pop de
549+  F16A D5               push de
550+  F16B 7B               ld a, e
551+  F16C CD 16 F4         call send_data_byte
552+  F16F D1               pop de
553+  F170 7A               ld a, d
554+  F171 CD 16 F4         call send_data_byte
555+  F174 C1               pop bc
556+  F175 C5               push bc
557+  F176 79               ld a, c
558+  F177 CD 16 F4         call send_data_byte
559+  F17A C1               pop bc
560+  F17B 78               ld a, b
561+  F17C CD 16 F4         call send_data_byte
562+  F17F CD 77 F4         call read_status_byte
563+  F182 FE 14            cp USB_INT_SUCCESS
564+  F184 20 03            jr nz, move_to_file_pointer_fail        ; We expect USB_INT_SUCCESS here
565+  F186
566+  F186 3E 14            ld a, USB_INT_SUCCESS                   ; Return success
567+  F188 C9               ret
568+  F189              move_to_file_pointer_fail:
569+  F189 3E 1F            ld a, USB_INT_DISK_ERR                  ; Return fail
570+  F18B C9               ret
571+  F18C
572+  F18C              set_random_pointer_in_fcb:
573+  F18C                  ; pass in de -> fcb
574+  F18C                  ; Pass hl = random pointer value
575+  F18C                  ; Random pointer goes to fcb + 33 & 34. fcb + 35 gets 0.
576+  F18C                  ; preserve de
577+  F18C D5               push de
578+  F18D EB               ex de, hl
579+  F18E 01 21 00         ld bc, 33
580+  F191 09               add hl, bc
581+  F192 73               ld (hl), e
582+  F193 23               inc hl
583+  F194 72               ld (hl), d
584+  F195 23               inc hl
585+  F196 36 00            ld (hl), 0
586+  F198 EB               ex de, hl
587+  F199 D1               pop de
588+  F19A C9               ret
589+  F19B
590+  F19B              set_file_size_in_fcb:
591+  F19B                  ; Pass HL -> FCB (Note that this is an unusual way to pass it in)
592+  F19B                  ; Pass file pointer (in 128-byte records) in bcde.
593+  F19B                  ; Preserves hl
594+  F19B
595+  F19B                  ; The following details are from http://www.primrosebank.net/computers/cpm/cpm_software_mfs.htm
596+  F19B                  ; RC = record counter, goes from 0 to $80. $80 means full, and represents 128*128=16K.
597+  F19B                  ; EX = 0 for files < 16K, otherwise 1 - 31 for Extents of 16K each.
598+  F19B                  ; S2 = high byte for the EXc ounter, so if EX wants to be bigger than 31, overflow it into here.
599+  F19B
600+  F19B                  ; Split bcde into S2, EX & RC.
601+  F19B                  ; To do this:
602+  F19B                  ; RC = e & %0111 1111               (i.e. a number 0..127)
603+  F19B                  ; Divide bcde by 128                (Shift right 7 bits, or shift left 1 bit then right 8)
604+  F19B                  ; EX = e & %0001 1111               (i.e. it has a max of 31)
605+  F19B                  ; Shift left 3 places
606+  F19B                  ; S2 = d
607+  F19B
608+  F19B                  ; RC = e & %0111 1111
609+  F19B E5               push hl
610+  F19C 7B               ld a, e
611+  F19D E6 7F            and %01111111                       ; RC is in A
612+  F19F
613+  F19F CB 23            sla e                               ; Shift all left by 1 bit
614+  F1A1 CB 12            rl d
615+  F1A3 CB 11            rl c
616+  F1A5 CB 10            rl b
617+  F1A7
618+  F1A7 5A               ld e, d                             ; Shift all right by 8 bits
619+  F1A8 51               ld d, c
620+  F1A9 48               ld c, b
621+  F1AA 06 00            ld b, 0                             ; We've effectively shifted right by 7 bits
622+  F1AC
623+  F1AC 01 0F 00         ld bc, 15                           ; ex is as FCB+12, s2 is at FCB+14, rc is at FCB + 15
624+  F1AF 09               add hl, bc                          ; hl -> FCB.RC
625+  F1B0 77               ld (hl), a                          ; RC is now stored in FCB
626+  F1B1
627+  F1B1 2B               dec hl
628+  F1B2 2B               dec hl
629+  F1B3 2B               dec hl                              ; hl -> FCB.EX
630+  F1B4 7B               ld a, e
631+  F1B5 E6 1F            and %00011111                       ; EX is in A
632+  F1B7 77               ld (hl), a
633+  F1B8
634+  F1B8 CB 23            sla e                               ; Shift all left by 1 bit
635+  F1BA CB 12            rl d
636+  F1BC CB 11            rl c
637+  F1BE CB 10            rl b
638+  F1C0 CB 23            sla e                               ; Shift all left by 1 bit
639+  F1C2 CB 12            rl d
640+  F1C4 CB 11            rl c
641+  F1C6 CB 10            rl b
642+  F1C8 CB 23            sla e                               ; Shift all left by 1 bit
643+  F1CA CB 12            rl d
644+  F1CC CB 11            rl c
645+  F1CE CB 10            rl b
646+  F1D0
647+  F1D0 23               inc hl
648+  F1D1 3E 00            ld a, 0
649+  F1D3 36 00            ld (hl), 0                          ; Blank out the mystery byte called "unused"
650+  F1D5 23               inc hl                              ; hl -> FCB.S2
651+  F1D6
652+  F1D6 7A               ld a, d
653+  F1D7 E6 1F            and %00011111                       ; S2 is in A
654+  F1D9 77               ld (hl), a
655+  F1DA
656+  F1DA E1               pop hl
657+  F1DB C9               ret
658+  F1DC
659+  F1DC              convert_user_number_to_folder_name:
660+  F1DC                  ; Pass in 1 to 15 in A.
661+  F1DC                  ; This returns "1" to "F"
662+  F1DC E6 0F            and %00001111
663+  F1DE C6 30            add a, '0'                             ; Convert 1-9 => "1".."9"
664+  F1E0 FE 3A            cp ':'
665+  F1E2 D8               ret c
666+  F1E3 C6 07            add a, 7
667+  F1E5 C9               ret
668+  F1E6
669+  F1E6                  include "memorystick_low_level.asm"
# file opened: memorystick_low_level.asm
  1++ F1E6              ; memorystick_low_level.asm
  2++ F1E6              ;--------------------;
  3++ F1E6              ; LOW LEVEL ROUTINES ;
  4++ F1E6              ;--------------------;
  5++ F1E6
  6++ F1E6              configure_memorystick:
  7++ F1E6 06 05            ld b, 5                                 ; Have 5 attempts at configuring the module before giving up
  8++ F1E8              configure_memorystick1:
  9++ F1E8 C5               push bc
 10++ F1E9 CD 64 F3         call connect_to_usb_drive
 11++ F1EC 20 08            jr nz, failed_to_setup
 12++ F1EE CD A8 F2         call connect_to_disk
 13++ F1F1 CD D7 F2         call mount_disk
 14++ F1F4 C1               pop bc
 15++ F1F5 C9               ret
 16++ F1F6              failed_to_setup:
 17++ F1F6 CD 19 ED         call long_pause
 18++ F1F9 CD 19 ED         call long_pause
 19++ F1FC CD 19 ED         call long_pause
 20++ F1FF CD 19 ED         call long_pause
 21++ F202 C1               pop bc
 22++ F203 10 E3            djnz configure_memorystick1
 23++ F205 CD 69 ED         call message
 24++ F208 43 48 33 37      db 'CH376S error.',13,10,0
 24++ F20C 36 53 20 65
 24++ F210 72 72 6F 72
 24++ F214 2E 0D 0A 00
 25++ F218 C9               ret
 26++ F219
 27++ F219              ;----------------------------------------------------------------
 28++ F219              ; Call this once at startup
 29++ F219              reset_ch376_module:
 30++ F219 3E 05            ld a, RESET_ALL
 31++ F21B CD 32 F4         call send_command_byte
 32++ F21E CD 19 ED         call long_pause
 33++ F221 CD 19 ED         call long_pause
 34++ F224 C9               ret
 35++ F225
 36++ F225              ;-----------------------------------------------------------------
 37++ F225              check_module_exists:
 38++ F225 3E 06            ld a, CHECK_EXIST
 39++ F227 CD 32 F4         call send_command_byte
 40++ F22A
 41++ F22A 3E 7B            ld a, 123               ; We send an arbitrary number
 42++ F22C CD 16 F4         call send_data_byte
 43++ F22F
 44++ F22F CD 3B F4         call read_data_byte
 45++ F232
 46++ F232 FE 84            cp 255-123      ; The result is 255 minus what we sent in
 47++ F234 C8               ret z
 48++ F235 CD 69 ED         call message
 49++ F238 45 52 52 4F      db 'ERROR: CH376S module not found.',13,10,0
 49++ F23C 52 3A 20 43
 49++ F240 48 33 37 36
 49++ F244 53 20 6D 6F
 49++ F248 64 75 6C 65
 49++ F24C 20 6E 6F 74
 49++ F250 20 66 6F 75
 49++ F254 6E 64 2E 0D
 49++ F258 0A 00
 50++ F25A C9               ret
 51++ F25B
 52++ F25B              ;-----------------------------------------------------------------
 53++ F25B              get_module_version:
 54++ F25B 3E 01            ld a, GET_IC_VER
 55++ F25D CD 32 F4         call send_command_byte
 56++ F260
 57++ F260 CD 3B F4         call read_data_byte
 58++ F263 E6 1F            and %00011111
 59++ F265
 60++ F265 CD 69 ED         call message
 61++ F268 46 6F 75 6E      db 'Found CH376S v',0 ; Mine is v3!!!
 61++ F26C 64 20 43 48
 61++ F270 33 37 36 53
 61++ F274 20 76 00
 62++ F277 CD 87 ED         call show_a_as_hex
 63++ F27A CD EE EC         call newline
 64++ F27D C9               ret
 65++ F27E
 66++ F27E              ;-----------------------------------------------------------------
 67++ F27E              set_usb_host_mode:
 68++ F27E 3E 15            ld a, SET_USB_MODE
 69++ F280 CD 32 F4         call send_command_byte
 70++ F283 3E 06            ld a, 6
 71++ F285 CD 16 F4         call send_data_byte
 72++ F288 CD 77 F4         call read_status_byte
 73++ F28B FE 15            cp USB_INT_CONNECT
 74++ F28D C8               ret z
 75++ F28E CD 69 ED         call message
 76++ F291 45 52 52 4F      db 'ERROR: No USB Disk?',13,10,0
 76++ F295 52 3A 20 4E
 76++ F299 6F 20 55 53
 76++ F29D 42 20 44 69
 76++ F2A1 73 6B 3F 0D
 76++ F2A5 0A 00
 77++ F2A7 C9               ret
 78++ F2A8
 79++ F2A8              ;-----------------------------------------------------------------
 80++ F2A8              connect_to_disk:
 81++ F2A8 3E 30            ld a, DISK_CONNECT
 82++ F2AA CD 32 F4         call send_command_byte
 83++ F2AD 3E 22            ld a, GET_STATUS
 84++ F2AF CD 77 F4         call read_status_byte
 85++ F2B2 C8               ret z
 86++ F2B3 CD 69 ED         call message
 87++ F2B6 45 52 52 4F      db 'ERROR connecting to USB Disk.',13,10,0
 87++ F2BA 52 20 63 6F
 87++ F2BE 6E 6E 65 63
 87++ F2C2 74 69 6E 67
 87++ F2C6 20 74 6F 20
 87++ F2CA 55 53 42 20
 87++ F2CE 44 69 73 6B
 87++ F2D2 2E 0D 0A 00
 88++ F2D6 C9               ret
 89++ F2D7
 90++ F2D7              ;-----------------------------------------------------------------
 91++ F2D7              mount_disk:
 92++ F2D7 3E 31            ld a, DISK_MOUNT
 93++ F2D9 CD 32 F4         call send_command_byte
 94++ F2DC 3E 22            ld a, GET_STATUS
 95++ F2DE CD 77 F4         call read_status_byte
 96++ F2E1 C8               ret z
 97++ F2E2 CD 69 ED         call message
 98++ F2E5 45 52 52 4F      db 'ERROR mounting USB Disk.',13,10,0
 98++ F2E9 52 20 6D 6F
 98++ F2ED 75 6E 74 69
 98++ F2F1 6E 67 20 55
 98++ F2F5 53 42 20 44
 98++ F2F9 69 73 6B 2E
 98++ F2FD 0D 0A 00
 99++ F300 C9               ret
100++ F301
101++ F301              ;-----------------------------------------------------------------
102++ F301              read_disk_signature:
103++ F301 3E 27            ld a, RD_USB_DATA0
104++ F303 CD 32 F4         call send_command_byte
105++ F306 CD 3B F4         call read_data_byte                 ; A = length of bytes to now read
106++ F309 FE 24            cp 36
107++ F30B 20 39            jr nz, could_not_read_disk_sig
108++ F30D
109++ F30D                  ; Ignore the first 8 bytes
110++ F30D 06 08            ld b, 8
111++ F30F              read_disk_signature1:
112++ F30F C5               push bc
113++ F310 CD 3E F4         call read_data_byte_silent
114++ F313 C1               pop bc
115++ F314 10 F9            djnz read_disk_signature1
116++ F316
117++ F316                  ; Display the next 8 bytes (Manufacturer)
118++ F316 06 08            ld b, 8
119++ F318              read_disk_signature2:
120++ F318 C5               push bc
121++ F319 CD 3E F4         call read_data_byte_silent
122++ F31C CD C1 EC         call print_a
123++ F31F C1               pop bc
124++ F320 10 F6            djnz read_disk_signature2
125++ F322 CD EE EC         call newline
126++ F325
127++ F325                  ; Display the next 16 bytes (Model)
128++ F325 06 10            ld b, 16
129++ F327              read_disk_signature3:
130++ F327 C5               push bc
131++ F328 CD 3E F4         call read_data_byte_silent
132++ F32B CD C1 EC         call print_a
133++ F32E C1               pop bc
134++ F32F 10 F6            djnz read_disk_signature3
135++ F331
136++ F331 3E 20            ld a, ' '
137++ F333 CD C1 EC         call print_a
138++ F336
139++ F336                  ; Display the next 4 bytes (Version)
140++ F336 06 04            ld b, 4
141++ F338              read_disk_signature4:
142++ F338 C5               push bc
143++ F339 CD 3E F4         call read_data_byte_silent
144++ F33C CD C1 EC         call print_a
145++ F33F C1               pop bc
146++ F340 10 F6            djnz read_disk_signature4
147++ F342 CD EE EC         call newline
148++ F345 C9               ret
149++ F346
150++ F346              could_not_read_disk_sig:
151++ F346 CD 69 ED         call message
152++ F349 45 52 52 4F      db 'ERROR reading disk sig.',13,10,0
152++ F34D 52 20 72 65
152++ F351 61 64 69 6E
152++ F355 67 20 64 69
152++ F359 73 6B 20 73
152++ F35D 69 67 2E 0D
152++ F361 0A 00
153++ F363 C9               ret
154++ F364
155++ F364              connect_to_usb_drive:
156++ F364                  ; Connects us up to the USB Drive.
157++ F364                  ; Returns Zero flag = true if we can connect ok.
158++ F364 CD 19 F2         call reset_ch376_module
159++ F367 CD 7E F2         call set_usb_host_mode
160++ F36A FE 15            cp USB_INT_CONNECT
161++ F36C C9               ret
162++ F36D
163++ F36D              create_file:
164++ F36D                  ; pass in DE = pointer to filename
165++ F36D D5               push de
166++ F36E 3E 2F            ld a, SET_FILE_NAME
167++ F370 CD 32 F4         call send_command_byte
168++ F373 E1               pop hl
169++ F374 CD 1C F4         call send_data_string
170++ F377
171++ F377 3E 34            ld a, FILE_CREATE
172++ F379 CD 32 F4         call send_command_byte
173++ F37C
174++ F37C CD 77 F4         call read_status_byte
175++ F37F FE 14            cp USB_INT_SUCCESS
176++ F381 C9               ret
177++ F382
178++ F382              open_file:
179++ F382                  ; Tells the module to use the filename from the filename_buffer.
180++ F382                  ; Returns z=true if ok to proceed.
181++ F382                  ; Pass in hl -> directory string, e.g. "/folder"
182++ F382              ;      push hl
183++ F382              ;      call message
184++ F382              ;      db 'open_file:[',0
185++ F382              ;  open_file1:
186++ F382              ;      ld a, (hl)
187++ F382              ;      cp 0
188++ F382              ;      jr z, open_file2
189++ F382              ;      call print_a
190++ F382              ;      inc hl
191++ F382              ;      jr open_file1
192++ F382
193++ F382              ;  open_file2:
194++ F382              ;      ld a, ']'
195++ F382              ;      call print_a
196++ F382              ;      call newline
197++ F382              ;      pop hl
198++ F382
199++ F382 3E 2F            ld a, SET_FILE_NAME
200++ F384 CD 32 F4         call send_command_byte
201++ F387 CD 1C F4         call send_data_string
202++ F38A 3E 32            ld a, FILE_OPEN
203++ F38C CD 32 F4         call send_command_byte
204++ F38F CD 77 F4         call read_status_byte
205++ F392 FE 14            cp USB_INT_SUCCESS
206++ F394 C9               ret
207++ F395
208++ F395              close_file:
209++ F395 3E 36            ld a, FILE_CLOSE
210++ F397 CD 32 F4         call send_command_byte
211++ F39A 3E 01            ld a, 1                             ; 1 = update file size if necessary
212++ F39C CD 16 F4         call send_data_byte
213++ F39F CD 77 F4         call read_status_byte
214++ F3A2 C9               ret
215++ F3A3
216++ F3A3              create_directory:
217++ F3A3                  ; Tells the module to use the filename from the filename_buffer to create a directory of that name.
218++ F3A3                  ; Returns z=true if ok to proceed.
219++ F3A3 21 EB FF         ld hl, filename_buffer
220++ F3A6              ; create_directory1:
221++ F3A6              ;     ld a, (hl)
222++ F3A6              ;     cp 0
223++ F3A6              ;     jr z, create_directory2
224++ F3A6              ;     inc hl
225++ F3A6              ;     call print_a
226++ F3A6              ;     jr create_directory1
227++ F3A6
228++ F3A6              create_directory2:
229++ F3A6
230++ F3A6 3E 2F            ld a, SET_FILE_NAME
231++ F3A8 CD 32 F4         call send_command_byte
232++ F3AB 21 EB FF         ld hl, filename_buffer
233++ F3AE CD 1C F4         call send_data_string
234++ F3B1 3E 40            ld a, DIR_CREATE
235++ F3B3 CD 32 F4         call send_command_byte
236++ F3B6 CD 77 F4         call read_status_byte
237++ F3B9 FE 14            cp USB_INT_SUCCESS
238++ F3BB C9               ret
239++ F3BC
240++ F3BC              read_from_file:
241++ F3BC                  ; Ask to read 128 bytes from the current file into the dma_address area pointed to by DE.
242++ F3BC                  ; Returns Zero flag set for success, clear for fail.
243++ F3BC D5               push de
244++ F3BD 3E 3A            ld a, BYTE_READ
245++ F3BF CD 32 F4         call send_command_byte
246++ F3C2 3E 80            ld a, 128                           ; Request 128 bytes
247++ F3C4 CD 16 F4         call send_data_byte
248++ F3C7 3E 00            ld a, 0
249++ F3C9 CD 16 F4         call send_data_byte
250++ F3CC
251++ F3CC CD 77 F4         call read_status_byte
252++ F3CF              read_from_file1:
253++ F3CF FE 1D            cp USB_INT_DISK_READ                    ; This means "go ahead and read"
254++ F3D1 28 07            jr z, read_from_file3
255++ F3D3 FE 14            cp USB_INT_SUCCESS                      ; Bizarrely this means we are finished
256++ F3D5 CA 06 F4         jp z, read_from_file_cannot
257++ F3D8 18 2C            jr read_from_file_cannot
258++ F3DA
259++ F3DA              read_from_file3:
260++ F3DA 3E 27            ld a, RD_USB_DATA0                      ; Find out how many bytes are available to read
261++ F3DC CD 32 F4         call send_command_byte
262++ F3DF CD 3B F4         call read_data_byte                     ; A = number of bytes available to read
263++ F3E2
264++ F3E2                  ; If there are less than 128 bytes to read, fill the buffer with 0s first
265++ F3E2 FE 80            cp 128
266++ F3E4 30 0B            jr nc, read_from_file_128
267++ F3E6 E1               pop hl
268++ F3E7 E5               push hl
269++ F3E8 F5               push af
270++ F3E9 06 80            ld b, 128
271++ F3EB              read_from_file_padding:
272++ F3EB 36 00            ld (hl), 0
273++ F3ED 23               inc hl
274++ F3EE 10 FB            djnz read_from_file_padding
275++ F3F0 F1               pop af
276++ F3F1
277++ F3F1              read_from_file_128:
278++ F3F1 E1               pop hl
279++ F3F2 CD 44 F4         call read_data_bytes_into_hl        ; Read this block of data
280++ F3F5 E5               push hl
281++ F3F6 3E 3B            ld a, BYTE_RD_GO
282++ F3F8 CD 32 F4         call send_command_byte
283++ F3FB 3E 22            ld a, GET_STATUS
284++ F3FD CD 32 F4         call send_command_byte
285++ F400 CD 3B F4         call read_data_byte
286++ F403 E1               pop hl
287++ F404                  ; All done, so return ZERO for success
288++ F404 BF               cp a                                ; set zero flag for success
289++ F405 C9               ret
290++ F406
291++ F406              read_from_file_cannot:
292++ F406 D1               pop de
293++ F407 F6 01            or 1                                ; clear zero flag
294++ F409 C9               ret
295++ F40A
296++ F40A              copy_filename_to_buffer:
297++ F40A                  ; Enter with hl->zero-terminated-filename-string
298++ F40A                  ; Copies this to filename_buffer
299++ F40A 11 EB FF         ld de, filename_buffer
300++ F40D              copy_filename_to_buffer1:
301++ F40D 7E               ld a, (hl)
302++ F40E 12               ld (de), a
303++ F40F 23               inc hl
304++ F410 13               inc de
305++ F411 FE 00            cp 0
306++ F413 C8               ret z
307++ F414 18 F7            jr copy_filename_to_buffer1
308++ F416
309++ F416              send_data_byte:
310++ F416                  ; push af
311++ F416                  ; call message
312++ F416                  ; db 'send_data_byte ', 0
313++ F416                  ; pop af
314++ F416                  ; push af
315++ F416                  ; call show_a_as_hex
316++ F416                  ; call newline
317++ F416                  ; pop af
318++ F416 D3 A0            out (mem_stick_data_port), a
319++ F418                  ;call tiny_pause
320++ F418 CD 4C F4         call wait_til_not_busy
321++ F41B C9               ret
322++ F41C
323++ F41C              send_data_string:
324++ F41C                  ; The string is pointed to by HL
325++ F41C 7E               ld a, (hl)
326++ F41D FE 00            cp 0
327++ F41F 28 0B            jr z, send_data_string_done
328++ F421 F5               push af
329++ F422 E5               push hl
330++ F423 CD 16 F4         call send_data_byte
331++ F426 E1               pop hl
332++ F427 F1               pop af
333++ F428 23               inc hl
334++ F429 C3 1C F4         jp send_data_string
335++ F42C              send_data_string_done:
336++ F42C 3E 00            ld a, 0
337++ F42E CD 16 F4         call send_data_byte
338++ F431 C9               ret
339++ F432
340++ F432              send_command_byte:
341++ F432                  ; push af
342++ F432                  ; call message
343++ F432                  ; db 'send_command_byte ',0
344++ F432                  ; pop af
345++ F432                  ; push af
346++ F432                  ; call show_a_as_hex
347++ F432                  ; call newline
348++ F432                  ; pop af
349++ F432 D3 A1            out (mem_stick_command_port), a
350++ F434                  ;call tiny_pause
351++ F434 CD 4C F4         call wait_til_not_busy
352++ F437 C9               ret
353++ F438
354++ F438              read_command_byte:
355++ F438                  ; call message
356++ F438                  ; db 'read_command_byte: ', 0
357++ F438 DB A1            in a, (mem_stick_command_port)
358++ F43A                  ; push af
359++ F43A                  ; call show_a_as_hex
360++ F43A                  ; call newline
361++ F43A                  ; pop af
362++ F43A C9               ret
363++ F43B
364++ F43B              read_data_byte:
365++ F43B                  ; call message
366++ F43B                  ; db 'read_data_byte: ', 0
367++ F43B DB A0            in a, (mem_stick_data_port)
368++ F43D                  ; push af
369++ F43D                  ; call show_a_as_hex
370++ F43D                  ; call newline
371++ F43D                  ; pop af
372++ F43D C9               ret
373++ F43E
374++ F43E              read_data_byte_silent:
375++ F43E DB A0            in a, (mem_stick_data_port)
376++ F440 C9               ret
377++ F441
378++ F441              read_data_bytes_into_buffer:
379++ F441                  ; The number of bytes should be in A.
380++ F441                  ; Read that many bytes into the buffer.
381++ F441                  ; The value of A is retained.
382++ F441 21 C5 FF         ld hl, disk_buffer
383++ F444              read_data_bytes_into_hl:
384++ F444                  ; This entry point will read A bytes into the area pointed to by HL.
385++ F444                  ; On exit HL will point to the location after where the bytes were added.
386++ F444 F5               push af
387++ F445 47               ld b, a
388++ F446 0E A0            ld c, mem_stick_data_port
389++ F448              read_data_bytes_into_buffer1:
390++ F448 ED B2            inir                    ; A rare use of In, Increase & Repeat!!!
391++ F44A F1               pop af
392++ F44B C9               ret
393++ F44C
394++ F44C              wait_til_not_busy:
395++ F44C                  ; call message
396++ F44C                  ; db 'waiting...', 13, 10, 0
397++ F44C 01 60 EA         ld bc, 60000            ; retry max 60000 times!!!
398++ F44F              wait_til_not_busy1:
399++ F44F C5               push bc
400++ F450 CD 38 F4         call read_command_byte
401++ F453 E6 10            and %00010000
402++ F455 C2 5A F4         jp nz, wait_til_not_busy2
403++ F458 C1               pop bc
404++ F459 C9               ret
405++ F45A              wait_til_not_busy2:
406++ F45A CD 23 ED         call short_pause
407++ F45D C1               pop bc
408++ F45E 0B               dec bc
409++ F45F 78               ld a, b
410++ F460 B1               or c
411++ F461 20 EC            jr nz, wait_til_not_busy1
412++ F463 CD 69 ED         call message
413++ F466 5B 55 53 42      db '[USB TIMEOUT]', 13, 10, 0
413++ F46A 20 54 49 4D
413++ F46E 45 4F 55 54
413++ F472 5D 0D 0A 00
414++ F476 C9               ret
415++ F477
416++ F477              read_status_byte:
417++ F477 3E 22            ld a, GET_STATUS
418++ F479 CD 32 F4         call send_command_byte
419++ F47C CD 3B F4         call read_data_byte
420++ F47F C9               ret
421++ F480
422++ F480              ; show_status:
423++ F480              ;     call read_status_byte
424++ F480              ;     push af
425++ F480              ;     call report_on_status
426++ F480              ;     pop af
427++ F480              ;     ret                     ; The status is returned in A
428++ F480
429++ F480              ; report_on_status:
430++ F480              ;     cp USB_INT_SUCCESS
431++ F480              ;     jr nz, ros1
432++ F480              ;     call message
433++ F480              ;     db 'USB_INT_SUCCESS',13,10,0
434++ F480              ;     ret
435++ F480              ; ros1:
436++ F480              ;     cp USB_INT_CONNECT
437++ F480              ;     jr nz, ros2
438++ F480              ;     call message
439++ F480              ;     db 'USB_INT_CONNECT',13,10,0
440++ F480              ;     ret
441++ F480              ; ros2:
442++ F480              ;     cp USB_INT_DISCONNECT
443++ F480              ;     jr nz, ros3
444++ F480              ;     call message
445++ F480              ;     db 'USB_INT_DISCONNECT',13,10,0
446++ F480              ;     ret
447++ F480              ; ros3:
448++ F480              ;     cp USB_INT_BUF_OVER
449++ F480              ;     jr nz, ros4
450++ F480              ;     call message
451++ F480              ;     db 'USB_INT_BUF_OVER',13,10,0
452++ F480              ;     ret
453++ F480              ; ros4:
454++ F480              ;     cp USB_INT_USB_READY
455++ F480              ;     jr nz, ros5
456++ F480              ;     call message
457++ F480              ;     db 'USB_INT_USB_READY',13,10,0
458++ F480              ;     ret
459++ F480              ; ros5:
460++ F480              ;     cp USB_INT_DISK_READ
461++ F480              ;     jr nz, ros6
462++ F480              ;     call message
463++ F480              ;     db 'USB_INT_DISK_READ',13,10,0
464++ F480              ;     ret
465++ F480              ; ros6:
466++ F480              ;     cp USB_INT_DISK_WRITE
467++ F480              ;     jr nz, ros7
468++ F480              ;     call message
469++ F480              ;     db 'USB_INT_DISK_WRITE',13,10,0
470++ F480              ;     ret
471++ F480              ; ros7:
472++ F480              ;     cp USB_INT_DISK_ERR
473++ F480              ;     jr nz, ros8
474++ F480              ;     call message
475++ F480              ;     db 'USB_INT_DISK_ERR',13,10,0
476++ F480              ;     ret
477++ F480              ; ros8:
478++ F480              ;     cp YES_OPEN_DIR
479++ F480              ;     jr nz, ros9
480++ F480              ;     call message
481++ F480              ;     db 'YES_OPEN_DIR',13,10,0
482++ F480              ;     ret
483++ F480              ; ros9:
484++ F480              ;     cp ERR_MISS_FILE
485++ F480              ;     jr nz, ros10
486++ F480              ;     call message
487++ F480              ;     db 'ERR_MISS_FILE',13,10,0
488++ F480              ;     ret
489++ F480              ; ros10:
490++ F480              ;     cp ERR_FOUND_NAME
491++ F480              ;     jr nz, ros11
492++ F480              ;     call message
493++ F480              ;     db 'ERR_FOUND_NAME',13,10,0
494++ F480              ;     ret
495++ F480              ; ros11:
496++ F480              ;     cp ERR_DISK_DISCON
497++ F480              ;     jr nz, ros12
498++ F480              ;     call message
499++ F480              ;     db 'ERR_DISK_DISCON',13,10,0
500++ F480              ;     ret
501++ F480              ; ros12:
502++ F480              ;     cp ERR_LARGE_SECTOR
503++ F480              ;     jr nz, ros13
504++ F480              ;     call message
505++ F480              ;     db 'ERR_LARGE_SECTOR',13,10,0
506++ F480              ;     ret
507++ F480              ; ros13:
508++ F480              ;     cp ERR_TYPE_ERROR
509++ F480              ;     jr nz, ros14
510++ F480              ;     call message
511++ F480              ;     db 'ERR_TYPE_ERROR',13,10,0
512++ F480              ;     ret
513++ F480              ; ros14:
514++ F480              ;     cp ERR_BPB_ERROR
515++ F480              ;     jr nz, ros15
516++ F480              ;     call message
517++ F480              ;     db 'ERR_BPB_ERROR',13,10,0
518++ F480              ;     ret
519++ F480              ; ros15:
520++ F480              ;     cp ERR_DISK_FULL
521++ F480              ;     jr nz, ros16
522++ F480              ;     call message
523++ F480              ;     db 'ERR_DISK_FULL',13,10,0
524++ F480              ;     ret
525++ F480              ; ros16:
526++ F480              ;     cp ERR_FDT_OVER
527++ F480              ;     jr nz, ros17
528++ F480              ;     call message
529++ F480              ;     db 'ERR_FDT_OVER',13,10,0
530++ F480              ;     ret
531++ F480              ; ros17:
532++ F480              ;     cp ERR_FILE_CLOSE
533++ F480              ;     jr nz, ros18
534++ F480              ;     call message
535++ F480              ;     db 'ERR_FILE_CLOSE',13,10,0
536++ F480              ;     ret
537++ F480              ; ros18:
538++ F480              ;     call message
539++ F480              ;     db 'UNKNOWN STATUS: ',0
540++ F480              ;     call show_a_as_hex
541++ F480              ;     call newline
542++ F480              ;     ret
543++ F480
544++ F480
545++ F480              mem_stick_data_port     equ 0xA0
546++ F480              mem_stick_command_port  equ 0xA1
547++ F480
548++ F480              GET_IC_VER equ $01
549++ F480              SET_BAUDRATE equ $02
550++ F480              RESET_ALL equ $05
551++ F480              CHECK_EXIST equ $06
552++ F480              GET_FILE_SIZE equ $0C
553++ F480              SET_USB_MODE equ $15
554++ F480              GET_STATUS equ $22
555++ F480              RD_USB_DATA0 equ $27
556++ F480              WR_USB_DATA equ $2C
557++ F480              WR_REQ_DATA equ $2D
558++ F480              WR_OFS_DATA equ $2E
559++ F480              SET_FILE_NAME equ $2F
560++ F480              DISK_CONNECT equ $30
561++ F480              DISK_MOUNT equ $31
562++ F480              FILE_OPEN equ $32
563++ F480              FILE_ENUM_GO equ $33
564++ F480              FILE_CREATE equ $34
565++ F480              FILE_ERASE equ $35
566++ F480              FILE_CLOSE equ $36
567++ F480              DIR_INFO_READ equ $37
568++ F480              DIR_INFO_SAVE equ $38
569++ F480              BYTE_LOCATE equ $39
570++ F480              BYTE_READ equ $3A
571++ F480              BYTE_RD_GO equ $3B
572++ F480              BYTE_WRITE equ $3C
573++ F480              BYTE_WR_GO equ $3D
574++ F480              DISK_CAPACITY equ $3E
575++ F480              DISK_QUERY equ $3F
576++ F480              DIR_CREATE equ $40
577++ F480
578++ F480
579++ F480              ; Statuses
580++ F480              USB_INT_SUCCESS equ $14
581++ F480              USB_INT_CONNECT equ $15
582++ F480              USB_INT_DISCONNECT equ $16
583++ F480              USB_INT_BUF_OVER equ $17
584++ F480              USB_INT_USB_READY equ $18
585++ F480              USB_INT_DISK_READ equ $1D
586++ F480              USB_INT_DISK_WRITE equ $1E
587++ F480              USB_INT_DISK_ERR equ $1F
588++ F480              YES_OPEN_DIR equ $41
589++ F480              ERR_MISS_FILE equ $42
590++ F480              ERR_FOUND_NAME equ $43
591++ F480              ERR_DISK_DISCON equ $82
592++ F480              ERR_LARGE_SECTOR equ $84
593++ F480              ERR_TYPE_ERROR equ $92
594++ F480              ERR_BPB_ERROR equ $A1
595++ F480              ERR_DISK_FULL equ $B1
596++ F480              ERR_FDT_OVER equ $B2
597++ F480              ERR_FILE_CLOSE equ $B4
598++ F480
599++ F480              ROOT_DIRECTORY:
600++ F480 2A 00            db '*',0
601++ F482
602++ F482              SLASH:
603++ F482 2F 00            db '/',0
604++ F484
605++ F484              ;SAVE_FILENAME:
606++ F484              ;    db 'TESTING',0
607++ F484
608++ F484              ;TARGET_FILENAME:
609++ F484              ;    db '/TARGET2.TXT',0
610++ F484
611++ F484              ;NO_EXTENSION:
612++ F484              ;    db '   ',0
613++ F484
614++ F484              ;TXT_EXTENSION:
615++ F484              ;    db 'TXT',0
616++ F484
# file closed: memorystick_low_level.asm
670+  F484
671+  F484              ROOT_NAME:
672+  F484 2F 00            db '/',0
673+  F486
674+  F486              STAR_DOT_STAR:
675+  F486 2A 00            db '*',0
676+  F488
677+  F488              CPM_FOLDER_NAME:
678+  F488 2F 43 50 4D      db '/CPM',0
678+  F48C 00
679+  F48D
680+  F48D              TINY_BASIC_FOLDER_NAME:
681+  F48D 2F 54 42 41           db '/TBASIC',0
681+  F491 53 49 43 00
682+  F495
683+  F495              CPM_DISKS_NAME:
684+  F495 44 49 53 4B      db 'DISKS',0
684+  F499 53 00
685+  F49B
686+  F49B
687+  F49B
# file closed: memorystick.asm
126   F49B                  include "PPI.asm"
# file opened: PPI.asm
  1+  F49B              INIT_PIO:
  2+  F49B 3E 80                	LD      A, 0x80 			; All ports output A,B and C
  3+  F49D D3 AB        	        OUT     (PIO_M), A		;
  4+  F49F C9                       RET
  5+  F4A0
  6+  F4A0
  7+  F4A0              change_to_slot2:
  8+  F4A0 E5               push    HL
  9+  F4A1
 10+  F4A1                  ;call    teste_na_rom
 11+  F4A1 3E AA        	LD      A, 0xAA
 12+  F4A3 D3 A8        	OUT     (PIO_A), A
 13+  F4A5                  ;call    teste_na_ram
 14+  F4A5
 15+  F4A5
 16+  F4A5                  ; Copy the first 16k of ROM down to ram LD (DE),(HL),
 17+  F4A5 21 B1 F4     	ld hl,  RamAddr000
 18+  F4A8 11 00 00     	ld de,  0
 19+  F4AB 01 80 00     	ld bc,	128
 20+  F4AE ED B0        	ldir
 21+  F4B0 C9               ret
 22+  F4B1
 23+  F4B1
 24+  F4B1              ;teste_na_ram:
 25+  F4B1                  ;call CORE_message
 26+  F4B1                  ;db 'Testing ram 1000: ',13,10,0
 27+  F4B1                  ;ld  hl,1000
 28+  F4B1                  ;ld  A, 0xA5
 29+  F4B1                  ;ld  (hl),a
 30+  F4B1                  ;ld  A, 0x5A
 31+  F4B1                  ;ld A,(hl)
 32+  F4B1                  ;cp  A, 0xA5
 33+  F4B1                  ;jp  NZ, cont
 34+  F4B1                  ;call CORE_message
 35+  F4B1                  ;db 'We are in RAM',13,10,0
 36+  F4B1                  ;jp  cont2
 37+  F4B1              ;cont:
 38+  F4B1                  ;call CORE_message
 39+  F4B1                  ;db 'We are NOT in RAM',13,10,0
 40+  F4B1              ;    halt
 41+  F4B1              ;cont2:
 42+  F4B1              ;    pop     HL
 43+  F4B1              ;copy_ram:
 44+  F4B1              ;    ret
 45+  F4B1
 46+  F4B1              ;teste_na_rom:
 47+  F4B1              ;    call CORE_message
 48+  F4B1              ;    db 'Testing ram 1000: ',13,10,0
 49+  F4B1              ;    ld  hl,1000
 50+  F4B1              ;    ld  A, 0xA5
 51+  F4B1              ;    ld  (hl),a
 52+  F4B1              ;    ld  A, 0x5A
 53+  F4B1              ;    ld A,(hl)
 54+  F4B1              ;    cp  A, 0xA5
 55+  F4B1              ;    jp  NZ, cont1
 56+  F4B1              ;    call CORE_message
 57+  F4B1              ;    db 'We are in RAM',13,10,0
 58+  F4B1              ;    jp  cont21
 59+  F4B1              ;cont1:
 60+  F4B1              ;    call CORE_message
 61+  F4B1              ;    db 'We are NOT in RAM',13,10,0
 62+  F4B1              ;cont21:
 63+  F4B1              ;    ret
# file closed: PPI.asm
127   F4B1                  include "cpm000.asm"
# file opened: cpm000.asm
  1+  F4B1                  ;org     0x0000
  2+  F4B1              RamAddr000:
  3+  F4B1 C3 00 DC         jp      BIOS_START      ;Warm boot jump to bios
  4+  F4B4 03               db      0x3               ;iobyte
  5+  F4B5 00               DS      1               ;disk byte
  6+  F4B6 C3 00 D0         jp      BDOS_START      ;system call
  7+  F4B9                  ;Restart vector 7  generally used by debuggers
  8+  F4B9              	;org 0x0038
  9+  F4B9              int:
 10+  F4B9 ED 4D        	reti
 11+  F4BB                  ;Bios work area
 12+  F4BB                  ;org 0x0040
 13+  F4BB 30 30 30 30      db  '0000000000000000'
 13+  F4BF 30 30 30 30
 13+  F4C3 30 30 30 30
 13+  F4C7 30 30 30 30
 14+  F4CB                  ;Unused area in CP/M 2.2
 15+  F4CB                  ;org 0x0050
 16+  F4CB 30 30 30 30      db  '0000000000000000'
 16+  F4CF 30 30 30 30
 16+  F4D3 30 30 30 30
 16+  F4D7 30 30 30 30
 17+  F4DB                  ;FCB Default file control block
 18+  F4DB                  ;org 0x0060
 19+  F4DB 30 30 30 30      db  '0000000000000000'
 19+  F4DF 30 30 30 30
 19+  F4E3 30 30 30 30
 19+  F4E7 30 30 30 30
 20+  F4EB 30 30 30 30      db  '0000000000000000'
 20+  F4EF 30 30 30 30
 20+  F4F3 30 30 30 30
 20+  F4F7 30 30 30 30
 21+  F4FB                  ;File buffer 128 bytes
 22+  F4FB                  ;org 0x0080
 23+  F4FB                  ;db  '0000000000000000000000000000000000000000000000000000000000000000'
 24+  F4FB                  ;db  '0000000000000000000000000000000000000000000000000000000000000000'
 25+  F4FB
# file closed: cpm000.asm
128   F4FB
129   F4FB              filename_buffer 	equ 65535-20
130   F4FB              DRIVE_NAME 			equ filename_buffer-2
131   F4FB              disk_buffer 		equ DRIVE_NAME-36
132   F4FB
133   F4FB              CORE_END equ $
134   F4FB
135   F4FB                  IF CORE_END-CORE_START>CORE_SIZE
136   F4FB ~                    .WARNING "The CORE is too big! CORE_SIZE bytes max!"
137   F4FB                  ENDIF
# file closed: core.asm
