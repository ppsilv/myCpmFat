# file opened: core.asm
  1   0000              ; CORE.ASM
  2   0000              ; These are Z80-Playground-specific routines that are available for CP/M or other
  3   0000              ; programs to use. They include routines for sending chars to the screen, reading
  4   0000              ; from the keyboard, and dealing with the USB Drive.
  5   0000              ; There is also a small monitor, so if you want to configure the INT
  6   0000              ; button to take you to the monitor, you can.
  7   0000
  8   0000              ; CORE takes the top 3K of memory, $F400 - $FFFF
  9   0000              ; It assembles to 2.53K right now.
 10   0000
 11   0000                  include "locations.asm"
# file opened: locations.asm
  1+  0000              ; locations.asm
  2+  0000              ; Stores the ORG values for the CCP, BDOS, BIOS and CORE
  3+  0000
  4+  0000              ;CORE_START  equ $F600    ; $FFFF - 2.5K
  5+  0000              ;BIOS_START  equ $F400    ; $F600 - 0.5K
  6+  0000              ;BDOS_START  equ $EA00    ; $F400 - 2.5K
  7+  0000              ;CCP_START   equ $DE00    ; $EA00 - 3.0K
  8+  0000
  9+  0000              CORE_START  equ $EC00    ; 5119
 10+  0000              BIOS_START  equ $DC00    ; 4096
 11+  0000              BDOS_START  equ $D000    ; 3072
 12+  0000              CCP_START   equ $B000    ; 8192
 13+  0000
 14+  0000              CORE_SIZE   equ 0xFFFF-CORE_START
 15+  0000              BIOS_SIZE   equ CORE_START-BIOS_START
 16+  0000              BDOS_SIZE   equ BIOS_START-BDOS_START
 17+  0000              CCP_SIZE    equ BDOS_START-CCP_START
# file closed: locations.asm
 12   0000
 13   0000                  org CORE_START
 14   EC00
 15   EC00              ; CORE internal jump table
 16   EC00              ; For future-proofing, all calls are via this jump table.
 17   EC00              ; From external code just jump to "CORE_configure_uart" or similar, which then jumps to "configure_uart".
 18   EC00              ; That way you can change the value of CORE_ORG, re-assemble this file, then in other files
 19   EC00              ; just include the external jump table.
 20   EC00              ; That way it doesn't matter if these routines change location or size, you can always access them from the jump table.
 21   EC00              CORE_start_monitor:
 22   EC00                  ; Start the debugging monitor
 23   EC00 C3 84 EC         jp unimplemented_start_monitor
 24   EC03              CORE_configure_uart:
 25   EC03                  ; Configures the 16550 UART after a reset, setting the baud rate etc.
 26   EC03 C3 94 EC         jp configure_uart
 27   EC06              CORE_print_a:
 28   EC06                  ; Prints whatever is in A to the screen, as a character.
 29   EC06 C3 DB EC         jp print_a
 30   EC09              CORE_char_in:
 31   EC09                  ; Reads a character from the keyboard into A
 32   EC09 C3 19 ED         jp char_in
 33   EC0C              CORE_char_available:
 34   EC0C                  ; Checks whether a character is available from the keyboard, without actually reading it
 35   EC0C C3 26 ED         jp char_available
 36   EC0F              CORE_short_pause:
 37   EC0F C3 3D ED         jp short_pause
 38   EC12              CORE_medium_pause:
 39   EC12 C3 38 ED         jp medium_pause
 40   EC15              CORE_long_pause:
 41   EC15 C3 33 ED         jp long_pause
 42   EC18
 43   EC18              CORE_disk_toggle:
 44   EC18 C3 47 ED         jp disk_toggle
 45   EC1B              CORE_disk_on:
 46   EC1B C3 54 ED         jp disk_on
 47   EC1E              CORE_disk_off:
 48   EC1E C3 4D ED         jp disk_off
 49   EC21
 50   EC21              CORE_user_toggle:
 51   EC21 C3 62 ED         jp user_toggle
 52   EC24              CORE_user_on:
 53   EC24 C3 5B ED         jp user_on
 54   EC27              CORE_user_off:
 55   EC27 C3 68 ED         jp user_off
 56   EC2A
 57   EC2A              CORE_rom_toggle:
 58   EC2A C3 6F ED         jp rom_toggle
 59   EC2D              CORE_rom_on:
 60   EC2D C3 75 ED         jp rom_on
 61   EC30              CORE_rom_off:
 62   EC30 C3 7C ED         jp rom_off
 63   EC33
 64   EC33              CORE_newline:
 65   EC33                  ; Prints a CR/NL combo
 66   EC33 C3 08 ED         jp newline
 67   EC36              CORE_space:
 68   EC36                  ; prints a space
 69   EC36 C3 13 ED         jp space
 70   EC39
 71   EC39              CORE_message:
 72   EC39 C3 83 ED         jp message
 73   EC3C              CORE_show_hl_as_hex:
 74   EC3C C3 98 ED         jp show_hl_as_hex
 75   EC3F              CORE_show_all:
 76   EC3F C3 C4 ED         jp show_all
 77   EC42
 78   EC42              CORE_dir:
 79   EC42 C3 28 EE         jp dir
 80   EC45              CORE_dir_next:
 81   EC45 C3 2C EF         jp dir_next
 82   EC48              CORE_load_bin_file:
 83   EC48 C3 37 EF         jp load_bin_file
 84   EC4B              CORE_dir_info_read:
 85   EC4B C3 C5 EF         jp dir_info_read
 86   EC4E              CORE_dir_info_write:
 87   EC4E C3 E5 EF         jp dir_info_write
 88   EC51              CORE_write_to_file:
 89   EC51 C3 1F F0         jp write_to_file
 90   EC54              CORE_erase_file:
 91   EC54 C3 5C F0         jp erase_file
 92   EC57              CORE_check_cpmdisks_structure:
 93   EC57 C3 E0 F0         jp check_cpmdisks_structure
 94   EC5A              CORE_move_to_file_pointer:
 95   EC5A C3 7C F1         jp move_to_file_pointer
 96   EC5D              CORE_set_random_pointer_in_fcb:
 97   EC5D C3 A6 F1         jp set_random_pointer_in_fcb
 98   EC60              CORE_copy_filename_to_buffer:
 99   EC60 C3 24 F4         jp copy_filename_to_buffer
100   EC63              CORE_open_file:
101   EC63 C3 9C F3         jp open_file
102   EC66              CORE_create_directory
103   EC66 C3 BD F3         jp create_directory
104   EC69              CORE_close_file:
105   EC69 C3 AF F3         jp close_file
106   EC6C              CORE_read_from_file:
107   EC6C C3 D6 F3         jp read_from_file
108   EC6F              CORE_connect_to_disk:
109   EC6F C3 C2 F2         jp connect_to_disk
110   EC72              CORE_mount_disk:
111   EC72 C3 F1 F2         jp mount_disk
112   EC75              CORE_create_file:
113   EC75 C3 87 F3         jp create_file
114   EC78              CORE_show_a_as_hex:
115   EC78 C3 A1 ED         jp show_a_as_hex
116   EC7B              CORE_convert_user_number_to_folder_name:
117   EC7B C3 F6 F1         jp convert_user_number_to_folder_name
118   EC7E              CORE_set_file_size_in_fcb:
119   EC7E C3 B5 F1         jp set_file_size_in_fcb
120   EC81              CORE_change_to_slot2:
121   EC81 C3 BA F4         jp change_to_slot2
122   EC84
123   EC84                  include "uart.asm"
# file opened: uart.asm
  1+  EC84              ; uart routines
  2+  EC84              ; These are routines connected with the 16C550 uart.
  3+  EC84
  4+  EC84              unimplemented_start_monitor:
  5+  EC84              	; Not implemented yet
  6+  EC84 C9           	ret
  7+  EC85
  8+  EC85              UART_FREQUENCY: EQU 19660800	; 82C50 | 16C550 CLOCK
  9+  EC85
 10+  EC85 80 00        UART_BAUD_9600:		DW	UART_FREQUENCY/(9600 * 16)
 11+  EC87 55 00        UART_BAUD_14400:	DW	UART_FREQUENCY/(14400 * 16)
 12+  EC89 40 00        UART_BAUD_19200:	DW	UART_FREQUENCY/(19200 * 16)
 13+  EC8B 20 00        UART_BAUD_38400:	DW	UART_FREQUENCY/(38400 * 16)
 14+  EC8D 15 00        UART_BAUD_57600:	DW	UART_FREQUENCY/(57600 * 16)
 15+  EC8F 0A 00        UART_BAUD_115200:	DW	UART_FREQUENCY/(115200 * 16)
 16+  EC91
 17+  EC91              ; Initialises the 16c550c UART for input/output
 18+  EC91              ;configure_uart:
 19+  EC91              	; Configure the UART 16550 after a reset.
 20+  EC91              	; For the sake of definitely getting the job done, let's pause here for ages before doing it.
 21+  EC91              	; Without this pause the Z80 can get started before the UART is ready.
 22+  EC91              	; Don't ask me how I know this.
 23+  EC91              	;
 24+  EC91              	; Pass in the required BAUD rate divisor in b.
 25+  EC91              	; Pass in the required hardware flow control in c.
 26+  EC91              ;	push bc
 27+  EC91              ;	call long_pause
 28+  EC91              ;	pop bc
 29+  EC91
 30+  EC91              ;	LD		A,	0x00
 31+  EC91              ;	OUT 	(uart_IER),A			; Disable interrupts
 32+  EC91
 33+  EC91              ;    ld 		A,	80H                 ; Go into "Divisor Latch Setting mode"
 34+  EC91              ;    out 	(uart_LCR),a            ; by writing 1 into bit 7 of the Line Control register
 35+  EC91              ;    nop								; These tiny "nop" pauses probably do nothing. TODO: Try removing them!
 36+  EC91
 37+  EC91              ;    ld 		A, b                    ; low byte of divisor
 38+  EC91              ;    out 	(uart_tx_rx), A
 39+  EC91              ;    nop
 40+  EC91              ;    ld 		A, 0                          ; high byte
 41+  EC91              ;    out 	(uart_IER), A
 42+  EC91              ;    nop
 43+  EC91
 44+  EC91              ;    ld a,03H                        ; Configure stop bits etc, and exit
 45+  EC91                                                  ; "Divisor latch setting mode"
 46+  EC91
 47+  EC91              ;    out (uart_LCR),a                ; 8 bits, no parity, 1 stop bit, bit 7 = 0
 48+  EC91              ;	nop								; a slight pause to allow the UART to get going
 49+  EC91
 50+  EC91              ;	ld a, 0x81 						;%10000001					; Turn on FIFO, with trigger level of 8.
 51+  EC91              ;	out (uart_ISR), a				; This definitely helps receive 16 chars very fast!
 52+  EC91
 53+  EC91              	;ld a, c
 54+  EC91              	;cp 0
 55+  EC91              	;jr z, flowcontrol_done
 56+  EC91
 57+  EC91              	;LD      A,0x00                  ;no flow control
 58+  EC91              	;ld a, %00100010
 59+  EC91              	;out (uart_MCR), a				; Enable auto flow control for /RTS and /CTS
 60+  EC91              ;	ret
 61+  EC91              flowcontrol_done:
 62+  EC91 00           	nop
 63+  EC92 00           	nop
 64+  EC93 C9               ret
 65+  EC94
 66+  EC94              configure_uart:
 67+  EC94 F5           UART_INIT:	PUSH	AF
 68+  EC95 7E           			LD		A,(HL)
 69+  EC96 23           			INC 	HL
 70+  EC97 66           			LD		H,(HL)
 71+  EC98 6F           			LD 		L,A
 72+  EC99 3E 00        			LD		A,0x00
 72+  EC9B D3 B9          OUT (uart_IER),A	; Disable interrupts
 73+  EC9D 3E 80        			LD		A,0x80
 73+  EC9F D3 BB          OUT (uart_LCR),A 	; Turn DLAB on
 74+  ECA1 7D           			LD		A,L
 74+  ECA2 D3 B8         	OUT (uart_tx_rx),A	; Set divisor low
 75+  ECA4 7C           			LD		A,H
 75+  ECA5 D3 B9         	OUT (uart_IER),A	; Set divisor high
 76+  ECA7 F1           			POP		AF
 76+  ECA8 D3 BB         		OUT (uart_LCR),A	; Write out flow control bits 8,1,N
 77+  ECAA 3E 81        			LD 		A, 0x81						; Turn on FIFO, with trigger level of 8.
 78+  ECAC D3 BA        			OUT (uart_ISR), A					; This turn on the 16bytes buffer!
 79+  ECAE C9           			RET
 80+  ECAF
 81+  ECAF              configure_uart_cpm:
 82+  ECAF 26 00        			LD		H, 0x00
 83+  ECB1 6F           			LD 		L,A
 84+  ECB2 3E 00        			LD		A,0x00
 84+  ECB4 D3 B9          OUT (uart_IER),A	; Disable interrupts
 85+  ECB6 3E 80        			LD		A,0x80
 85+  ECB8 D3 BB          OUT (uart_LCR),A 	; Turn DLAB on
 86+  ECBA 7D           			LD		A,L
 86+  ECBB D3 B8         	OUT (uart_tx_rx),A	; Set divisor low
 87+  ECBD 7C           			LD		A,H
 87+  ECBE D3 B9         	OUT (uart_IER),A	; Set divisor high
 88+  ECC0 3E 03        			LD		A, 0x03
 88+  ECC2 D3 BB         		OUT (uart_LCR),A	; Write out flow control bits 8,1,N
 89+  ECC4 3E 81        			LD 		A, 0x81						; Turn on FIFO, with trigger level of 8.
 90+  ECC6 D3 BA        			OUT (uart_ISR), A					; This turn on the 16bytes buffer!
 91+  ECC8 C9           			RET
 92+  ECC9
 93+  ECC9              UART_TX_WAIT		EQU	600		; Count before a TX times out
 94+  ECC9
 95+  ECC9              ; A: Data read
 96+  ECC9              ; Returns:
 97+  ECC9              ; F = C if character read
 98+  ECC9              ; F = NC if no character read
 99+  ECC9              ;
100+  ECC9 DB BD        UART_RX:	IN	A,(uart_LSR)		; Get the line status register
101+  ECCB E6 01        			AND 	0x01				; Check for characters in buffer
102+  ECCD C8           			ret	Z					; Just ret (with carry clear) if no characters
103+  ECCE DB B8        			IN	A,(uart_tx_rx)		; Read the character from the UART receive buffer
104+  ECD0 37           			SCF 						; Set the carry flag
105+  ECD1 C9           			RET
106+  ECD2
107+  ECD2              ; Read a character - waits for input
108+  ECD2              ; NB is the non-blocking variant
109+  ECD2              ;  A: ASCII character read
110+  ECD2              ;  F: NC if no character read (non-blocking)
111+  ECD2              ;  F:  C if character read (non-blocking)
112+  ECD2              ;
113+  ECD2 CD C9 EC     Read_Char:              CALL    UART_RX
114+  ECD5 30 FB                                JR      NC,Read_Char
115+  ECD7 C9                                   RET
116+  ECD8              ; Read a character - NO waits for input
117+  ECD8              ; NB is the non-blocking variant
118+  ECD8              ;  A: ASCII character read
119+  ECD8              ;  F: NC if no character read (non-blocking)
120+  ECD8              ;  F:  C if character read (non-blocking)
121+  ECD8 C3 C9 EC     Read_Char_NB:           JP      UART_RX
122+  ECDB
123+  ECDB              ; Print A to the screen as an ASCII character, preserving all registers.
124+  ECDB              print_a:
125+  ECDB E5           UART_TX:	PUSH 	HL
126+  ECDC D5           			PUSH 	DE
127+  ECDD C5           			PUSH	BC						; Stack BC
128+  ECDE F5           			PUSH	AF 						; Stack AF
129+  ECDF 06 58        			LD	B,low  UART_TX_WAIT			; Set CB to the transmit timeout
130+  ECE1 0E 02        			LD	C,high UART_TX_WAIT
131+  ECE3 DB BD        1:			IN	A,(uart_LSR)			; Get the line status register
132+  ECE5 E6 60        			AND 	0x60					; Check for TX empty
133+  ECE7 20 0B        			JR	NZ,2F						; If set, then TX is empty, goto transmit
134+  ECE9 10 F8        			DJNZ	1B
134+  ECEB 0D             DEC	C
134+  ECEC 20 F5          JR NZ,1B		; Otherwise loop
135+  ECEE F1           			POP	AF							; We've timed out at this point so
136+  ECEF B7           			OR	A							; Clear the carry flag and preserve A
137+  ECF0 C1           			POP	BC							; Restore the stack
138+  ECF1 D1           			POP DE
139+  ECF2 E1           			POP	HL
140+  ECF3 C9           			RET
141+  ECF4 F1           2:			POP	AF							; Good to send at this point, so
142+  ECF5 D3 B8        			OUT	(uart_tx_rx),A			; Write the character to the UART transmit buffer
143+  ECF7 CD FF EC     			call	delay2
144+  ECFA C1           			POP	BC							; Restore the stack
145+  ECFB D1           			POP DE
146+  ECFC E1           			POP	HL
147+  ECFD 37           			SCF								; Set the carry flag
148+  ECFE C9           			RET
149+  ECFF              ;******************************************************************
150+  ECFF              ; This routine delay 746us
151+  ECFF              delay2:
152+  ECFF F5           			PUSH   AF
153+  ED00 3E FF        			LD     A, 0xFF
154+  ED02 3D           delay2loop: DEC    A
155+  ED03 C2 02 ED     			JP     NZ, delay2loop  ; JUMP TO DELAYLOOP2 IF A <> 0.
156+  ED06 F1           			POP    AF
157+  ED07 C9           			RET
158+  ED08
159+  ED08              ;    push af                         ; Store A for a bit
160+  ED08              ;print_a1:
161+  ED08              ;    in a,(uart_LSR)                 ; check UART is ready to send.
162+  ED08              ;    bit 5,a                         ; zero flag set to true if bit 5 is 0
163+  ED08              ;    jp z, print_a1                  ; non-zero = ready for next char.;
164+  ED08
165+  ED08              ;    pop af                          ; UART IS READY, GET OLD "A" BACK
166+  ED08              ;    out (uart_tx_rx),a              ; AND SEND IT OUT
167+  ED08              ;	ret
168+  ED08
169+  ED08              newline:
170+  ED08 3E 0D        	ld a,13
171+  ED0A CD DB EC     	call print_a
172+  ED0D 3E 0A        	ld a,10
173+  ED0F CD DB EC     	call print_a
174+  ED12 C9           	ret
175+  ED13
176+  ED13              space:
177+  ED13 3E 20        	ld a,32
178+  ED15 CD DB EC     	call print_a
179+  ED18 C9           	ret
180+  ED19
181+  ED19              ; To receive a char over Serial we need to check if there is one. If not we return 0.
182+  ED19              ; If there is, we get it and return it (in a).
183+  ED19              char_in:
184+  ED19 DB BD        	in a,(uart_LSR)			; get status from Line Status Register
185+  ED1B CB 47        	bit 0,a					; zero flag set to true if bit 0 is 0 (bit 0 = Receive Data Ready)
186+  ED1D              							; "logic 0 = no data in receive holding register."
187+  ED1D CA 23 ED     	jp z,char_in1    		; zero = no char received
188+  ED20 DB B8        	in a,(uart_tx_rx)		; Get the incoming char
189+  ED22 C9           	ret						; Return it in A
190+  ED23              char_in1:
191+  ED23 3E 00        	ld a,0					; Return a zero in A
192+  ED25 C9           	ret
193+  ED26
194+  ED26              char_available:
195+  ED26 DB BD        	in a,(uart_LSR)			; get status from Line Status Register
196+  ED28 CB 47        	bit 0,a					; zero flag set to true if bit 0 is 0 (bit 0 = Receive Data Ready)
197+  ED2A              							; "logic 0 = no data in receive holding register."
198+  ED2A CA 30 ED     	jp z,char_available1	; zero = no char received
199+  ED2D 3E FF        	ld a, $FF		        ; return true
200+  ED2F C9           	ret						; in A
201+  ED30              char_available1:
202+  ED30 3E 00        	ld a,0					; Return a zero in A
203+  ED32 C9           	ret
204+  ED33
205+  ED33
206+  ED33              long_pause:
207+  ED33 01 E8 FD     	ld bc,65000
208+  ED36 18 08            jr pause0
209+  ED38              medium_pause:
210+  ED38 01 C8 AF     	ld bc,45000
211+  ED3B 18 03            jr pause0
212+  ED3D              short_pause:
213+  ED3D 01 64 00     	ld bc,100
214+  ED40              pause0:
215+  ED40 0B           	dec bc
216+  ED41 78           	ld a,b
217+  ED42 B1           	or c
218+  ED43 C2 40 ED     	jp nz,pause0
219+  ED46 C9           	ret
220+  ED47
221+  ED47              disk_toggle:
222+  ED47 DB BC        	in a, (uart_MCR)
223+  ED49 E6 04        	and %00000100
224+  ED4B 28 07        	jr z, disk_on
225+  ED4D              	; fall through to...
226+  ED4D              disk_off:
227+  ED4D               	; disk light off
228+  ED4D DB BC        	in a, (uart_MCR)
229+  ED4F E6 FB        	and %11111011
230+  ED51 D3 BC        	out (uart_MCR), a
231+  ED53 C9           	ret
232+  ED54
233+  ED54              disk_on:
234+  ED54              	; disk light on
235+  ED54 DB BC        	in a, (uart_MCR)
236+  ED56 F6 04        	or %00000100
237+  ED58 D3 BC        	out (uart_MCR), a
238+  ED5A C9           	ret
239+  ED5B
240+  ED5B              user_on:
241+  ED5B              	; user light on
242+  ED5B DB BC        	in a, (uart_MCR)
243+  ED5D F6 01        	or %00000001
244+  ED5F D3 BC        	out (uart_MCR), a
245+  ED61 C9           	ret
246+  ED62
247+  ED62              user_toggle:
248+  ED62              	; user1 light invert
249+  ED62 DB BC        	in a, (uart_MCR)
250+  ED64 E6 01        	and %00000001
251+  ED66 28 F3        	jr z, user_on
252+  ED68              	; fall through to...
253+  ED68              user_off:
254+  ED68               	; user light off
255+  ED68 DB BC        	in a, (uart_MCR)
256+  ED6A E6 FE        	and %11111110
257+  ED6C D3 BC        	out (uart_MCR), a
258+  ED6E C9           	ret
259+  ED6F
260+  ED6F              rom_toggle:
261+  ED6F DB BC        	in a, (uart_MCR)
262+  ED71 E6 08        	and %00001000
263+  ED73 28 07        	jr z, rom_off
264+  ED75              	; fall through to...
265+  ED75              rom_on:
266+  ED75              	; rom light on
267+  ED75 DB BC        	in a, (uart_MCR)
268+  ED77 E6 F7        	and %11110111
269+  ED79 D3 BC        	out (uart_MCR), a
270+  ED7B C9           	ret
271+  ED7C
272+  ED7C              rom_off:
273+  ED7C              	; rom light off
274+  ED7C DB BC        	in a, (uart_MCR)
275+  ED7E F6 08        	or %00001000
276+  ED80 D3 BC        	out (uart_MCR), a
277+  ED82 C9           	ret
278+  ED83
279+  ED83              	include "port_numbers.asm"
# file opened: port_numbers.asm
  1++ ED83              ; port_numbers.asm
  2++ ED83
  3++ ED83              ; Here are the port numbers for various UART registers:
  4++ ED83              uart_tx_rx 		equ   0xB8   ; 	8
  5++ ED83              uart_IER 		equ   0xB9   ; 	9
  6++ ED83              uart_ISR 		equ   0xBA   ;  10  ; Also known as FCR
  7++ ED83              uart_LCR 		equ   0xBB   ;  11
  8++ ED83              uart_MCR 		equ   0xBC   ;  12  ; modem control reg
  9++ ED83              uart_LSR 		equ   0xBD   ;  13
 10++ ED83              uart_MSR 		equ   0xBE   ;  14
 11++ ED83              uart_scratch 	equ   0xBF   ;  15
 12++ ED83
 13++ ED83              PIO_A	equ	0xA8		; CA80 user 8255 base address 	  (port A)
 14++ ED83              PIO_B	equ	0xA9		; CA80 user 8255 base address + 1 (port B)
 15++ ED83              PIO_C	equ	0xAA		; CA80 user 8255 base address + 2 (fport C)
 16++ ED83              PIO_M	equ	0xAB		; CA80 user 8255 control register
 17++ ED83
# file closed: port_numbers.asm
280+  ED83
# file closed: uart.asm
124   ED83                  include "message.asm"
# file opened: message.asm
  1+  ED83              ; message
  2+  ED83              message:
  3+  ED83 E3           	ex (sp), hl                   ; top of stack is now mangled, but hl is pointing to our message
  4+  ED84 F5           	push	af
  5+  ED85 C5           	push	bc
  6+  ED86 D5           	push	de
  7+  ED87
  8+  ED87              message_loop_001:
  9+  ED87 7E           	ld a, (hl)
 10+  ED88 FE 00        	cp 0
 11+  ED8A 28 06        	jr z, message_complete_001
 12+  ED8C 23           	inc hl
 13+  ED8D CD DB EC     	call print_a                  ; print a character (Mangles 2 items below top of stack)
 14+  ED90 18 F5        	jr message_loop_001               ; Loop until done
 15+  ED92
 16+  ED92              message_complete_001:
 17+  ED92 D1           	pop de
 18+  ED93 C1           	pop bc
 19+  ED94 F1           	pop af
 20+  ED95 23           	inc hl
 21+  ED96 E3           	ex (sp), hl
 22+  ED97 C9           	ret
 23+  ED98
 24+  ED98
 25+  ED98              ; -------------------------------------------------------------------------------------------------
 26+  ED98
 27+  ED98              ;message:
 28+  ED98              ;	; Use this handy helper function to display an inline message easily.
 29+  ED98              ;	; It preserves all registers (which was tricky to do).
 30+  ED98              ;	; This expects to be called from code where the message follows the "call debug" in-line, like this:
 31+  ED98              ;	;
 32+  ED98              ;	; ld a, 10 ; (or whatever code you like)
 33+  ED98              ;	; call message
 34+  ED98              ;	; db "my message", 0
 35+  ED98              ;	; ld b, 10 ; (or whatever code you like)
 36+  ED98              ;	;
 37+  ED98              ;	; When we return we make sure sp is pointing to the next line of code after the message.
 38+  ED98              ;
 39+  ED98              ;							; sp -> ret-addr
 40+  ED98              ;
 41+  ED98              ;	push af					; We have stored af
 42+  ED98              ;	push af					; We do this 3 times
 43+  ED98              ;	push af					; to allow spare stack space.
 44+  ED98              ;							; sp -> AF, AF, AF, ret-addr
 45+  ED98              ;	push bc					; sp -> BC, AF, AF, AF, ret-addr
 46+  ED98              ;	push de					; sp -> DE, BC, AF, AF, AF, ret-addr
 47+  ED98              ;	push hl					; sp -> HL, DE, BC, AF, AF, AF, ret-addr
 48+  ED98              ;
 49+  ED98              ;	inc sp
 50+  ED98              ;	inc sp					; adjust the stack to overlook the stored afx3, BC, DE & HL
 51+  ED98              ;							; HL, sp -> DE, BC, AF, AF, AF, ret-addr
 52+  ED98              ;	inc sp
 53+  ED98              ;	inc sp					; HL, DE, sp -> BC, AF, AF, AF, ret-addr
 54+  ED98              ;
 55+  ED98              ;	inc sp
 56+  ED98              ;	inc sp					; HL, DE, BC, sp -> AF, AF, AF, ret-addr
 57+  ED98              ;
 58+  ED98              ;	inc sp
 59+  ED98              ;	inc sp
 60+  ED98              ;
 61+  ED98              ;	inc sp
 62+  ED98              ;	inc sp
 63+  ED98              ;
 64+  ED98              ;	inc sp
 65+  ED98              ;	inc sp					; HL, DE, BC, AF, AF, AF, sp -> ret-addr
 66+  ED98              ;
 67+  ED98              ;	ex (sp), hl				; top of stack is now mangled, but hl is pointing to our message
 68+  ED98              ;							; HL, DE, BC, AF, AF, AF, sp -> HL
 69+  ED98              ;
 70+  ED98              ;message_loop:
 71+  ED98              ;	ld a, (hl)
 72+  ED98              ;	cp 0
 73+  ED98              ;	jr z,message_complete
 74+  ED98              ;	inc hl
 75+  ED98              ;	call print_a			; print a character (Mangles 2 items below top of stack)
 76+  ED98              ;	jr message_loop			; Loop until done
 77+  ED98              ;							; HL, DE, BC, AF, XX, XX, sp -> HL
 78+  ED98              ;
 79+  ED98              ;message_complete:
 80+  ED98              ;	inc hl
 81+  ED98              ;	ex (sp), hl				; restore top of stack, after we have incremented it so it points to the subsequent instruction
 82+  ED98              ;							; HL, DE, BC, AF, XX, XX, sp -> new-ret-addr
 83+  ED98              ;	dec sp
 84+  ED98              ;	dec sp
 85+  ED98              ;
 86+  ED98              ;	dec sp
 87+  ED98              ;	dec sp
 88+  ED98              ;
 89+  ED98              ;	dec sp
 90+  ED98              ;	dec sp					; adjust stack because of our pushed "af"
 91+  ED98              ;							; HL, DE, BC, sp -> AF, XX, XX, new-ret-addr
 92+  ED98              ;	dec sp
 93+  ED98              ;	dec sp					; adjust stack because of our pushed "BC"
 94+  ED98              ;							; HL, DE, sp -> BC, AF, XX, XX, new-ret-addr
 95+  ED98              ;	dec sp
 96+  ED98              ;	dec sp					; adjust stack because of our pushed "DE"
 97+  ED98              ;							; HL, sp -> DE, BC, AF, XX, XX, new-ret-addr
 98+  ED98              ;	dec sp
 99+  ED98              ;	dec sp					; adjust stack because of our pushed "HL"
100+  ED98              ;							; sp -> HL, DE, BC, AF, XX, XX, new-ret-addr
101+  ED98              ;
102+  ED98              ;	pop hl					; HL is restored
103+  ED98              ;							; sp -> DE, BC, AF, XX, XX, new-ret-addr
104+  ED98              ;	pop de					; DE is restored
105+  ED98              ;							; sp -> BC, AF, XX, XX, new-ret-addr
106+  ED98              ;	pop bc					; BC is restored
107+  ED98              ;							; sp -> AF, XX, XX, new-ret-addr
108+  ED98              ;	pop af					; we have restored af
109+  ED98              ;							; sp -> XX, XX, new-ret-addr
110+  ED98              ;
111+  ED98              ;	inc sp
112+  ED98              ;	inc sp
113+  ED98              ;	inc sp
114+  ED98              ;	inc sp
115+  ED98              ;							; sp -> new-ret-addr
116+  ED98              ;
117+  ED98              ;	ret						; return to the instruction after the message
118+  ED98
119+  ED98              show_hl_as_hex:
120+  ED98 7C               ld a, h
121+  ED99 CD A1 ED         call show_a_as_hex
122+  ED9C 7D               ld a, l
123+  ED9D CD A1 ED         call show_a_as_hex
124+  EDA0 C9               ret
125+  EDA1
126+  EDA1              show_a_as_hex:
127+  EDA1 F5               push af
128+  EDA2 CB 3F            srl a
129+  EDA4 CB 3F            srl a
130+  EDA6 CB 3F            srl a
131+  EDA8 CB 3F            srl a
132+  EDAA C6 30            add a,'0'
133+  EDAC FE 3A        	cp ':'
134+  EDAE 38 02        	jr c, show_a_as_hex1
135+  EDB0 C6 07        	add a, 7
136+  EDB2              show_a_as_hex1:
137+  EDB2 CD DB EC         call print_a
138+  EDB5 F1               pop af
139+  EDB6 E6 0F            and %00001111
140+  EDB8 C6 30            add a,'0'
141+  EDBA FE 3A        	cp ':'
142+  EDBC 38 02        	jr c, show_a_as_hex2
143+  EDBE C6 07        	add a, 7
144+  EDC0              show_a_as_hex2:
145+  EDC0 CD DB EC         call print_a
146+  EDC3 C9               ret
147+  EDC4
148+  EDC4              ;---------------------------------------------------
149+  EDC4              ; show_all shows all the CPU registers!
150+  EDC4
151+  EDC4              show_all:
152+  EDC4 ED 73 23 EE  	ld (store_sp), sp
153+  EDC8 F5           	push af
154+  EDC9 E5           	push hl
155+  EDCA D5           	push de
156+  EDCB C5           	push bc
157+  EDCC
158+  EDCC CD 83 ED     	call message
159+  EDCF 41 3D 00     	db 'A=',0
160+  EDD2 CD A1 ED     	call show_a_as_hex
161+  EDD5
162+  EDD5 E1           	pop hl
163+  EDD6 CD 83 ED     	call message
164+  EDD9 2C 20 42 43  	db ', BC=',0
164+  EDDD 3D 00
165+  EDDF CD 98 ED     	call show_hl_as_hex
166+  EDE2 C5           	push bc
167+  EDE3
168+  EDE3 C1           	pop bc
169+  EDE4 E1           	pop hl
170+  EDE5 CD 83 ED     	call message
171+  EDE8 2C 20 44 45  	db ', DE=',0
171+  EDEC 3D 00
172+  EDEE CD 98 ED     	call show_hl_as_hex
173+  EDF1 D5           	push de
174+  EDF2 C5           	push bc
175+  EDF3
176+  EDF3 C1           	pop bc
177+  EDF4 D1           	pop de
178+  EDF5 E1           	pop hl
179+  EDF6 CD 83 ED     	call message
180+  EDF9 2C 20 48 4C  	db ', HL=',0
180+  EDFD 3D 00
181+  EDFF CD 98 ED     	call show_hl_as_hex
182+  EE02 E5           	push hl
183+  EE03 D5           	push de
184+  EE04 C5           	push bc
185+  EE05
186+  EE05 CD 83 ED     	call message
187+  EE08 2C 20 53 50  	db ', SP=',0
187+  EE0C 3D 00
188+  EE0E 2A 23 EE     	ld hl, (store_sp)
189+  EE11 CD 98 ED     	call show_hl_as_hex
190+  EE14
191+  EE14 3E 0D        	ld a, 13
192+  EE16 CD DB EC     	call print_a
193+  EE19 3E 0A        	ld a, 10
194+  EE1B CD DB EC     	call print_a
195+  EE1E
196+  EE1E C1           	pop bc
197+  EE1F D1           	pop de
198+  EE20 E1           	pop hl
199+  EE21 F1           	pop af
200+  EE22 C9           	ret
201+  EE23
202+  EE23              store_sp:
203+  EE23 00 00        	 ds 2
# file closed: message.asm
125   EE25                  include "memorystick.asm"
# file opened: memorystick.asm
  1+  EE25              ; memorystick.asm
  2+  EE25
  3+  EE25              store_de:
  4+  EE25 00 00            dw 0
  5+  EE27              store_a:
  6+  EE27 00               db 0
  7+  EE28              ;-----------------------------------------------------------------
  8+  EE28              ; For DIRectory listing, the filename is passed in the filename_buffer.
  9+  EE28              ; DE -> DMA AREA
 10+  EE28              ; a = Current User
 11+  EE28              ; It will be something like A/ffffffff.xxx
 12+  EE28              ; A result gets put into the area pointed to by DE, normally the DMA area, in 8.3 format
 13+  EE28              dir:
 14+  EE28 ED 53 25 EE      ld (store_de), de
 15+  EE2C 32 27 EE         ld (store_a), a
 16+  EE2F
 17+  EE2F CD 54 ED         call disk_on
 18+  EE32
 19+  EE32 21 A2 F4         ld hl, CPM_FOLDER_NAME                    ; Start at /CPM
 20+  EE35 CD 9C F3         call open_file
 21+  EE38 21 AF F4         ld hl, CPM_DISKS_NAME                    ; Then DISKS
 22+  EE3B CD 9C F3         call open_file
 23+  EE3E
 24+  EE3E 21 EB FF         ld hl, filename_buffer
 25+  EE41 7E               ld a, (hl)
 26+  EE42 21 E9 FF         ld hl, DRIVE_NAME                       ; Move to "A" .. "P" for required disk
 27+  EE45 77               ld (hl), a
 28+  EE46 23               inc hl
 29+  EE47 36 00            ld (hl), 0
 30+  EE49 2B               dec hl
 31+  EE4A CD 9C F3         call open_file
 32+  EE4D
 33+  EE4D                  ; Now user number (if greater than 0)
 34+  EE4D 3A 27 EE         ld a, (store_a)
 35+  EE50 FE 00            cp 0
 36+  EE52 28 0E            jr z, ignore_user
 37+  EE54
 38+  EE54 CD F6 F1         call convert_user_number_to_folder_name
 39+  EE57 21 E9 FF         ld hl, DRIVE_NAME                   ; Move to "1" .. "F" for required user
 40+  EE5A 77               ld (hl), a
 41+  EE5B 23               inc hl
 42+  EE5C 36 00            ld (hl), 0
 43+  EE5E 2B               dec hl
 44+  EE5F CD 9C F3         call open_file
 45+  EE62
 46+  EE62              ignore_user:
 47+  EE62 21 A0 F4         ld hl, STAR_DOT_STAR                    ; Specify search pattern "*"
 48+  EE65 CD 9C F3         call open_file
 49+  EE68
 50+  EE68                  ; Read a file if there is something to read
 51+  EE68              dir_loop:
 52+  EE68                  ; at this point DE is in store_de, containing address of dma-area
 53+  EE68 FE 1D            cp USB_INT_DISK_READ
 54+  EE6A 28 2E            jr z, dir_loop_good
 55+  EE6C
 56+  EE6C FE 42            cp ERR_MISS_FILE    ; This is what you normally get at the end of a dir listing
 57+  EE6E 28 24            jr z, dir_no_file
 58+  EE70
 59+  EE70 FE A1            cp ERR_BPB_ERROR    ; This means a disk format error
 60+  EE72 20 20            jr nz, dir_no_file
 61+  EE74
 62+  EE74 CD 83 ED         call message
 63+  EE77 55 53 42 20      db 'USB Drive ERROR: FAT only!',13,10,0
 63+  EE7B 44 72 69 76
 63+  EE7F 65 20 45 52
 63+  EE83 52 4F 52 3A
 63+  EE87 20 46 41 54
 63+  EE8B 20 6F 6E 6C
 63+  EE8F 79 21 0D 0A
 63+  EE93 00
 64+  EE94              dir_no_file:
 65+  EE94 CD 4D ED         call disk_off
 66+  EE97 3E FF            ld a, 255
 67+  EE99 C9               ret
 68+  EE9A
 69+  EE9A              dir_loop_good:
 70+  EE9A                  ; at this point DE is on stack, containing address of dma-area
 71+  EE9A 3E 27            ld a, RD_USB_DATA0
 72+  EE9C CD 4C F4         call send_command_byte
 73+  EE9F CD 55 F4         call read_data_byte                 ; Find out how many bytes there are to read
 74+  EEA2
 75+  EEA2 CD 5B F4         call read_data_bytes_into_buffer    ; read them into disk_buffer
 76+  EEA5 FE 20            cp 32                               ; Did we read at least 32 bytes?
 77+  EEA7 30 03            jr nc, good_length
 78+  EEA9 C3 2C EF         jp dir_next
 79+  EEAC
 80+  EEAC              good_length:
 81+  EEAC                  ; at this point DE is in store_de, containing address of dma-area
 82+  EEAC                  ; Get the attributes for this entry. $02 = system, $04 = hidden, $10 = directory
 83+  EEAC CD 4D ED         call disk_off
 84+  EEAF 3A D0 FF         ld a, (disk_buffer+11)
 85+  EEB2 E6 16            and $16                         ; Check for hidden or system files, or directories
 86+  EEB4 CA BA EE         jp z, it_is_not_system
 87+  EEB7 C3 2C EF         jp dir_next                     ; and skip accordingly.
 88+  EEBA
 89+  EEBA              it_is_not_system:
 90+  EEBA                  ; Does it match the search pattern?
 91+  EEBA 06 0B            ld b, 11
 92+  EEBC 21 C5 FF         ld hl, disk_buffer
 93+  EEBF 11 ED FF         ld de, filename_buffer+2
 94+  EEC2              matching_loop:
 95+  EEC2                  ; If the filename_buffer has a '.' then skip over it
 96+  EEC2                  ; and move disk_buffer to start of extension
 97+  EEC2 1A               ld a, (de)
 98+  EEC3 FE 2E            cp '.'
 99+  EEC5 20 06            jr nz, matching_loop1
100+  EEC7
101+  EEC7 13               inc de
102+  EEC8 21 CD FF         ld hl, disk_buffer+8
103+  EECB 06 03            ld b, 3
104+  EECD
105+  EECD              matching_loop1
106+  EECD 1A               ld a, (de)
107+  EECE FE 3F            cp '?'
108+  EED0 28 05            jr z, matching_loop_good
109+  EED2 BE               cp (hl)
110+  EED3 28 02            jr z, matching_loop_good
111+  EED5 18 55            jr dir_next
112+  EED7
113+  EED7              matching_loop_good:
114+  EED7 13               inc de
115+  EED8 23               inc hl
116+  EED9 10 E7            djnz matching_loop
117+  EEDB
118+  EEDB                  ; Copy 11 byte filename + extension
119+  EEDB 01 0B 00         ld bc, 11
120+  EEDE 21 C5 FF         ld hl, disk_buffer
121+  EEE1 ED 5B 25 EE      ld de, (store_de)
122+  EEE5
123+  EEE5                  ; The Usernumber goes into the first byte of the FCB
124+  EEE5 3A 27 EE         ld a, (store_a)
125+  EEE8 E6 0F            and %00001111
126+  EEEA 12               ld (de), a                      ; Store user number in FCB result
127+  EEEB 13               inc de
128+  EEEC ED B0            ldir                            ; Copy filename & extension
129+  EEEE
130+  EEEE                  ; Fill in a few more details. File size into normal place, plus random record info.
131+  EEEE                  ; The filesize is a 32 bit number in FAT_DIR_INFO at loc $1C, 1D, 1E and 1F.
132+  EEEE                  ; We want it in 128 byte sectors, so need to divide by 128.
133+  EEEE 21 E1 FF         ld hl, disk_buffer+$1C
134+  EEF1 5E               ld e, (hl)
135+  EEF2 23               inc hl
136+  EEF3 56               ld d, (hl)
137+  EEF4 23               inc hl
138+  EEF5 4E               ld c, (hl)
139+  EEF6 23               inc hl
140+  EEF7 46               ld b, (hl)                          ; BCDE has file size
141+  EEF8 EB               ex de, hl                           ; 32-bit filesize now in BCHL
142+  EEF9
143+  EEF9                  ; Divide by 128
144+  EEF9 CB 25            sla l                               ; Shift all left by 1 bit
145+  EEFB CB 14            rl h
146+  EEFD CB 11            rl c
147+  EEFF CB 10            rl b
148+  EF01
149+  EF01 6C               ld l, h
150+  EF02 61               ld h, c
151+  EF03 48               ld c, b
152+  EF04 06 00            ld b, 0                             ; We've shifted right 8 bits, so effectively divided by 128!
153+  EF06
154+  EF06 ED 5B 25 EE      ld de, (store_de)
155+  EF0A
156+  EF0A C5               push bc                             ; Store the size that is in bchl
157+  EF0B E5               push hl
158+  EF0C CD A6 F1         call set_random_pointer_in_fcb      ; store hl in FCB random pointer (bc is thrown away!)
159+  EF0F E1               pop hl
160+  EF10 C1               pop bc                              ; restore bchl
161+  EF11
162+  EF11 EB               ex de, hl                           ; hl = fcb, bcde = filesize
163+  EF12 2A 25 EE         ld hl, (store_de)
164+  EF15 CD B5 F1         call set_file_size_in_fcb
165+  EF18
166+  EF18                  ; Clear all 16 disk allocation bytes. TODO: Actually, fill with sensible values
167+  EF18 ED 5B 25 EE      ld de, (store_de)
168+  EF1C 21 10 00         ld hl, 16
169+  EF1F 19               add hl, de
170+  EF20 EB               ex de, hl
171+  EF21 06 14            ld b, 16+4
172+  EF23 3E 00            ld a, 0
173+  EF25              clear_allocation_loop:
174+  EF25 12               ld (de), a
175+  EF26 13               inc de
176+  EF27 10 FC            djnz clear_allocation_loop
177+  EF29              good_length1:
178+  EF29 3E 00            ld a, 0                                 ; 0 = success
179+  EF2B C9               ret
180+  EF2C
181+  EF2C              dir_next:
182+  EF2C 3E 33            ld a, FILE_ENUM_GO                      ; Go to next entry in the directory
183+  EF2E CD 4C F4         call send_command_byte
184+  EF31 CD 91 F4         call read_status_byte
185+  EF34 C3 68 EE         jp dir_loop
186+  EF37
187+  EF37              ;-----------------------------------------
188+  EF37              ; Load bin File
189+  EF37              ; The filename needs to be in the filename buffer.
190+  EF37              ; The file must be in the /CPM folder.
191+  EF37              ; DE points to the location to load it into.
192+  EF37              ; The file is loaded into the workspace.
193+  EF37              ; There is no check whether the file is too big!!!!
194+  EF37              ; Returns zero flag set if success, zero flag cleared on file-not-found.
195+  EF37
196+  EF37              load_bin_file:
197+  EF37 D5               push de                             ; Store target location for later
198+  EF38 CD 54 ED         call disk_on
199+  EF3B CD C2 F2         call connect_to_disk
200+  EF3E CD F1 F2         call mount_disk
201+  EF41
202+  EF41 21 A2 F4         ld hl, CPM_FOLDER_NAME              ; Start at /CPM
203+  EF44 CD 9C F3         call open_file
204+  EF47
205+  EF47 21 EB FF         ld hl, filename_buffer              ; Specify filename
206+  EF4A CD 9C F3         call open_file
207+  EF4D
208+  EF4D 28 2B            jr z, load_file_found
209+  EF4F CD 4D ED         call disk_off
210+  EF52 CD 83 ED         call message
211+  EF55 46 69 6C 65      db 'File not found ',0
211+  EF59 20 6E 6F 74
211+  EF5D 20 66 6F 75
211+  EF61 6E 64 20 00
212+  EF65 21 EB FF         ld hl, filename_buffer
213+  EF68              load_file1:
214+  EF68 7E               ld a, (hl)
215+  EF69 FE 00            cp 0
216+  EF6B 28 06            jr z, load_file2
217+  EF6D CD DB EC         call print_a
218+  EF70 23               inc hl
219+  EF71 18 F5            jr load_file1
220+  EF73              load_file2:
221+  EF73 CD 08 ED         call newline
222+  EF76 D1               pop de                              ; Keep stack clear!
223+  EF77 F6 01            or 1                                ; Clear zero flag for failure
224+  EF79 C9               ret
225+  EF7A              load_file_found:
226+  EF7A CD 4D ED         call disk_off
227+  EF7D 3E 3A            ld a, BYTE_READ
228+  EF7F CD 4C F4         call send_command_byte
229+  EF82 3E FF            ld a, 255                           ; Request all of the file
230+  EF84 CD 30 F4         call send_data_byte
231+  EF87 3E FF            ld a, 255                           ; Yes, all!
232+  EF89 CD 30 F4         call send_data_byte
233+  EF8C
234+  EF8C 3E 22            ld a, GET_STATUS
235+  EF8E CD 4C F4         call send_command_byte
236+  EF91 CD 55 F4         call read_data_byte
237+  EF94 E1               pop hl                              ; Get back the target address
238+  EF95              load_loop1:
239+  EF95 FE 1D            cp USB_INT_DISK_READ
240+  EF97 20 25            jr nz, load_finished
241+  EF99
242+  EF99 E5               push hl
243+  EF9A CD 54 ED         call disk_on
244+  EF9D 3E 27            ld a, RD_USB_DATA0
245+  EF9F CD 4C F4         call send_command_byte
246+  EFA2 CD 55 F4         call read_data_byte
247+  EFA5 E1               pop hl
248+  EFA6 CD 5E F4         call read_data_bytes_into_hl        ; Read this block of data
249+  EFA9 E5               push hl
250+  EFAA CD 4D ED         call disk_off
251+  EFAD 3E 3B            ld a, BYTE_RD_GO
252+  EFAF CD 4C F4         call send_command_byte
253+  EFB2 3E 22            ld a, GET_STATUS
254+  EFB4 CD 4C F4         call send_command_byte
255+  EFB7 CD 55 F4         call read_data_byte
256+  EFBA E1               pop hl
257+  EFBB C3 95 EF         jp load_loop1
258+  EFBE              load_finished:
259+  EFBE E5               push hl
260+  EFBF CD AF F3         call close_file
261+  EFC2 E1               pop hl
262+  EFC3 BF               cp a                                ; set zero flag for success
263+  EFC4 C9               ret
264+  EFC5
265+  EFC5              ; ---------------------------------
266+  EFC5              ; Directory info read.
267+  EFC5              ; Reads a directory entry (of the currently open file) into disk_buffer
268+  EFC5              ; Returns ZERO FLAG = set if ok
269+  EFC5              dir_info_read:
270+  EFC5 3E 37            ld a, DIR_INFO_READ
271+  EFC7 CD 4C F4         call send_command_byte
272+  EFCA 3E FF            ld a, $FF                           ; Current open file
273+  EFCC CD 30 F4         call send_data_byte
274+  EFCF
275+  EFCF CD 91 F4         call read_status_byte
276+  EFD2 FE 14            cp USB_INT_SUCCESS
277+  EFD4 C0               ret nz
278+  EFD5
279+  EFD5 3E 27            ld a, RD_USB_DATA0
280+  EFD7 CD 4C F4         call send_command_byte
281+  EFDA CD 55 F4         call read_data_byte                 ; Find out how many bytes there are to read
282+  EFDD
283+  EFDD CD 5B F4         call read_data_bytes_into_buffer
284+  EFE0 FE 20            cp $20                              ; Must have read 32 bytes
285+  EFE2 C0               ret nz                              ; or else it is an error
286+  EFE3              ;     call message
287+  EFE3              ;     db 'Read this many bytes: ',0
288+  EFE3              ;     call show_a_as_hex
289+  EFE3              ;     call newline
290+  EFE3
291+  EFE3              ;     ld b, $20
292+  EFE3              ;     ld hl, disk_buffer
293+  EFE3              ; dir_info_read1:
294+  EFE3              ;     ld a, (hl)
295+  EFE3              ;     push hl
296+  EFE3              ;     push bc
297+  EFE3              ;     call show_a_as_hex
298+  EFE3              ;     ld a, ','
299+  EFE3              ;     call print_a
300+  EFE3              ;     pop bc
301+  EFE3              ;     pop hl
302+  EFE3              ;     inc hl
303+  EFE3              ;     djnz dir_info_read1
304+  EFE3              ;     call newline
305+  EFE3
306+  EFE3 BF               cp a                                ; set zero flag for success
307+  EFE4 C9               ret
308+  EFE5
309+  EFE5              ; DIR_INFO_WRITE
310+  EFE5              ; writes a dir_info block from disk_buffer to the USB drive
311+  EFE5              ; for the currently open file
312+  EFE5              dir_info_write:
313+  EFE5 3E 37            ld a, DIR_INFO_READ
314+  EFE7 CD 4C F4         call send_command_byte
315+  EFEA 3E FF            ld a, $FF                           ; Current open file
316+  EFEC CD 30 F4         call send_data_byte
317+  EFEF
318+  EFEF CD 91 F4         call read_status_byte
319+  EFF2                  ;call report_on_status
320+  EFF2 FE 14            cp USB_INT_SUCCESS
321+  EFF4 20 28            jr nz, dir_info_write2
322+  EFF6
323+  EFF6 3E 2E            ld a, WR_OFS_DATA
324+  EFF8 CD 4C F4         call send_command_byte
325+  EFFB 3E 00            ld a, 0
326+  EFFD CD 30 F4         call send_data_byte
327+  F000 3E 20            ld a, $20
328+  F002 CD 30 F4         call send_data_byte
329+  F005 06 20            ld b, $20
330+  F007 21 C5 FF         ld hl, disk_buffer
331+  F00A              dir_info_write1:
332+  F00A 7E               ld a, (hl)
333+  F00B E5               push hl
334+  F00C C5               push bc
335+  F00D CD 30 F4         call send_data_byte
336+  F010 C1               pop bc
337+  F011 E1               pop hl
338+  F012 23               inc hl
339+  F013 10 F5            djnz dir_info_write1
340+  F015
341+  F015 3E 38            ld a, DIR_INFO_SAVE
342+  F017 CD 4C F4         call send_command_byte
343+  F01A CD 55 F4         call read_data_byte
344+  F01D                  ;call report_on_status
345+  F01D C9               ret
346+  F01E
347+  F01E              dir_info_write2:
348+  F01E C9               ret
349+  F01F
350+  F01F              ;----------------------------------
351+  F01F              ; WRITE TO FILE
352+  F01F
353+  F01F              write_to_file:
354+  F01F                  ; writes 128 bytes from current location pointed to by DE, to the open file
355+  F01F D5               push de
356+  F020 3E 3C            ld a, BYTE_WRITE
357+  F022 CD 4C F4         call send_command_byte
358+  F025
359+  F025                  ; Send number of bytes we are about to write, as 16 bit number, low first
360+  F025 3E 80            ld a, 128
361+  F027 CD 30 F4         call send_data_byte
362+  F02A 3E 00            ld a, 0
363+  F02C CD 30 F4         call send_data_byte
364+  F02F
365+  F02F E1               pop hl                              ; hl -> the data
366+  F030
367+  F030              write_loop
368+  F030 CD 91 F4         call read_status_byte
369+  F033 FE 1E            cp USB_INT_DISK_WRITE
370+  F035 20 24            jr nz, write_finished
371+  F037
372+  F037 E5               push hl
373+  F038                  ; Ask if we can send some bytes
374+  F038 3E 2D            ld a, WR_REQ_DATA
375+  F03A CD 4C F4         call send_command_byte
376+  F03D CD 55 F4         call read_data_byte
377+  F040 E1               pop hl
378+  F041 FE 00            cp 0
379+  F043 28 16            jr z, write_finished
380+  F045
381+  F045                  ; push hl
382+  F045                  ; push af
383+  F045                  ; call message
384+  F045                  ; db 'Bytes to send: ',0
385+  F045                  ; pop af
386+  F045                  ; push af
387+  F045                  ; call show_a_as_hex
388+  F045                  ; call newline
389+  F045                  ; pop af
390+  F045                  ; pop hl
391+  F045
392+  F045 47               ld b, a
393+  F046              block_loop:
394+  F046 7E               ld a, (hl)
395+  F047 E5               push hl
396+  F048 C5               push bc
397+  F049 CD 30 F4         call send_data_byte
398+  F04C C1               pop bc
399+  F04D E1               pop hl
400+  F04E 23               inc hl
401+  F04F 10 F5            djnz block_loop
402+  F051
403+  F051 E5               push hl
404+  F052 3E 3D            ld a, BYTE_WR_GO
405+  F054 CD 4C F4         call send_command_byte
406+  F057 E1               pop hl
407+  F058 C3 30 F0         jp write_loop
408+  F05B
409+  F05B              write_finished:
410+  F05B C9               ret
411+  F05C
412+  F05C
413+  F05C              ;-------------------------------------------
414+  F05C              ; ERASE FILE
415+  F05C
416+  F05C              erase_file:
417+  F05C 3E 2F            ld a, SET_FILE_NAME
418+  F05E CD 4C F4         call send_command_byte
419+  F061 21 EB FF         ld hl, filename_buffer
420+  F064 CD 36 F4         call send_data_string
421+  F067 3E 35            ld a, FILE_ERASE
422+  F069 CD 4C F4         call send_command_byte
423+  F06C CD 91 F4         call read_status_byte
424+  F06F C9               ret
425+  F070
426+  F070              show_filename_buffer:
427+  F070 21 EB FF         ld hl, filename_buffer
428+  F073 06 14            ld b, 20
429+  F075              show_filename_buffer1:
430+  F075 7E               ld a, (hl)
431+  F076 FE 20            cp 32
432+  F078 38 0A            jr c, control_char
433+  F07A              show_filename_buffer2
434+  F07A CD DB EC         call print_a
435+  F07D 23               inc hl
436+  F07E 10 F5            djnz show_filename_buffer1
437+  F080 CD 08 ED         call newline
438+  F083 C9               ret
439+  F084
440+  F084              control_char:
441+  F084 C6 40            add a, 64
442+  F086 4F               ld c, a
443+  F087 3E 5E            ld a, '^'
444+  F089 CD DB EC         call print_a
445+  F08C 79               ld a, c
446+  F08D 18 EB            jr show_filename_buffer2
447+  F08F
448+  F08F              check_tbasic_structure:
449+  F08F                  ; Check that there is a /TBASIC folder
450+  F08F                  ; and if not, make it!
451+  F08F CD 83 ED         call message
452+  F092 43 68 65 63      db 'Checking /TBASIC',13,10,0
452+  F096 6B 69 6E 67
452+  F09A 20 2F 54 42
452+  F09E 41 53 49 43
452+  F0A2 0D 0A 00
453+  F0A5
454+  F0A5 21 A7 F4         ld hl, TINY_BASIC_FOLDER_NAME
455+  F0A8 CD 24 F4         call copy_filename_to_buffer
456+  F0AB 21 EB FF         ld hl, filename_buffer
457+  F0AE CD 9C F3         call open_file
458+  F0B1 FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
459+  F0B3 C8               ret z                               ; If found, job done.
460+  F0B4 CD BD F3         call create_directory
461+  F0B7 C8               ret z                               ; If created ok, job done.
462+  F0B8 CD 83 ED         call message
463+  F0BB 45 52 52 4F      db 'ERROR creating Tiny Basic folder!',13,10,0
463+  F0BF 52 20 63 72
463+  F0C3 65 61 74 69
463+  F0C7 6E 67 20 54
463+  F0CB 69 6E 79 20
463+  F0CF 42 61 73 69
463+  F0D3 63 20 66 6F
463+  F0D7 6C 64 65 72
463+  F0DB 21 0D 0A 00
464+  F0DF C9               ret
465+  F0E0
466+  F0E0              check_cpmdisks_structure:
467+  F0E0                  ; Check that we have a disk structure like this:
468+  F0E0                  ; /CPMDISKS
469+  F0E0                  ;          /A
470+  F0E0                  ;          /B
471+  F0E0                  ;          /C
472+  F0E0                  ;          :
473+  F0E0                  ;          /P
474+  F0E0
475+  F0E0                  ; Loop over A..P
476+  F0E0 06 10            ld b, 16
477+  F0E2              check_cpmdisk_loop:
478+  F0E2 C5               push bc
479+  F0E3                  ; Go to /CPM
480+  F0E3 CD 83 ED         call message
481+  F0E6 43 68 65 63      db 'Checking /CPM',13,10,0
481+  F0EA 6B 69 6E 67
481+  F0EE 20 2F 43 50
481+  F0F2 4D 0D 0A 00
482+  F0F6
483+  F0F6 21 A2 F4         ld hl, CPM_FOLDER_NAME
484+  F0F9 CD 24 F4         call copy_filename_to_buffer
485+  F0FC 21 EB FF         ld hl, filename_buffer
486+  F0FF CD 9C F3         call open_file
487+  F102 FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
488+  F104 20 42            jr nz, check_cpmdisks_structure2
489+  F106
490+  F106 CD 83 ED         call message
491+  F109 43 68 65 63      db 'Checking /CPM/DISKS',13,10,0
491+  F10D 6B 69 6E 67
491+  F111 20 2F 43 50
491+  F115 4D 2F 44 49
491+  F119 53 4B 53 0D
491+  F11D 0A 00
492+  F11F 21 AF F4         ld hl, CPM_DISKS_NAME
493+  F122 CD 24 F4         call copy_filename_to_buffer
494+  F125 21 EB FF         ld hl, filename_buffer
495+  F128 CD 9C F3         call open_file
496+  F12B FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
497+  F12D 20 19            jr nz, check_cpmdisks_structure2
498+  F12F
499+  F12F C1               pop bc
500+  F130 C5               push bc
501+  F131 78               ld a, b
502+  F132 C6 40            add a, 'A'-1
503+  F134 32 EB FF         ld (filename_buffer), a
504+  F137 3E 00            ld a, 0
505+  F139 32 EC FF         ld (filename_buffer+1),a
506+  F13C 21 EB FF         ld hl, filename_buffer
507+  F13F CD 9C F3         call open_file
508+  F142 FE 41            cp YES_OPEN_DIR                     ; This is NOT an error, it is a badly named success code!!!!!!
509+  F144 20 0B            jr nz, check_cpmdisks_structure3
510+  F146
511+  F146 C1               pop bc                              ; Let's say if we find disk "P" then they are all there!!!
512+  F147                  ;djnz check_cpmdisk_loop
513+  F147
514+  F147 C9               ret
515+  F148
516+  F148              check_cpmdisks_structure2:
517+  F148 C1               pop bc
518+  F149                  ; Try to create the missing folder
519+  F149                  ;ld hl, CPMDISKS_NAME
520+  F149                  ;call copy_filename_to_buffer
521+  F149 CD BD F3         call create_directory
522+  F14C 20 0D            jr nz, check_cpmdisks_structure_fail
523+  F14E
524+  F14E                  ; Start all over again
525+  F14E C3 E0 F0         jp check_cpmdisks_structure
526+  F151
527+  F151              check_cpmdisks_structure3:
528+  F151 CD BD F3         call create_directory
529+  F154 20 04            jr nz, check_cpmdisks_subdir_fail
530+  F156 C1               pop bc                                          ; All good, so do the next subdir
531+  F157 C3 E2 F0         jp check_cpmdisk_loop
532+  F15A
533+  F15A              check_cpmdisks_subdir_fail:
534+  F15A C1               pop bc
535+  F15B                  ; Continue through to the next bit...
536+  F15B              check_cpmdisks_structure_fail:
537+  F15B CD 83 ED         call message
538+  F15E 45 52 52 4F      db 'ERROR creating CP/M disks!',13,10,0
538+  F162 52 20 63 72
538+  F166 65 61 74 69
538+  F16A 6E 67 20 43
538+  F16E 50 2F 4D 20
538+  F172 64 69 73 6B
538+  F176 73 21 0D 0A
538+  F17A 00
539+  F17B C9               ret
540+  F17C
541+  F17C              move_to_file_pointer:
542+  F17C                  ; Set the BYTE_LOCATE file position in the currently open file.
543+  F17C                  ; Value is passed in bcde.
544+  F17C C5               push bc
545+  F17D D5               push de
546+  F17E 3E 39            ld a, BYTE_LOCATE
547+  F180 CD 4C F4         call send_command_byte
548+  F183 D1               pop de
549+  F184 D5               push de
550+  F185 7B               ld a, e
551+  F186 CD 30 F4         call send_data_byte
552+  F189 D1               pop de
553+  F18A 7A               ld a, d
554+  F18B CD 30 F4         call send_data_byte
555+  F18E C1               pop bc
556+  F18F C5               push bc
557+  F190 79               ld a, c
558+  F191 CD 30 F4         call send_data_byte
559+  F194 C1               pop bc
560+  F195 78               ld a, b
561+  F196 CD 30 F4         call send_data_byte
562+  F199 CD 91 F4         call read_status_byte
563+  F19C FE 14            cp USB_INT_SUCCESS
564+  F19E 20 03            jr nz, move_to_file_pointer_fail        ; We expect USB_INT_SUCCESS here
565+  F1A0
566+  F1A0 3E 14            ld a, USB_INT_SUCCESS                   ; Return success
567+  F1A2 C9               ret
568+  F1A3              move_to_file_pointer_fail:
569+  F1A3 3E 1F            ld a, USB_INT_DISK_ERR                  ; Return fail
570+  F1A5 C9               ret
571+  F1A6
572+  F1A6              set_random_pointer_in_fcb:
573+  F1A6                  ; pass in de -> fcb
574+  F1A6                  ; Pass hl = random pointer value
575+  F1A6                  ; Random pointer goes to fcb + 33 & 34. fcb + 35 gets 0.
576+  F1A6                  ; preserve de
577+  F1A6 D5               push de
578+  F1A7 EB               ex de, hl
579+  F1A8 01 21 00         ld bc, 33
580+  F1AB 09               add hl, bc
581+  F1AC 73               ld (hl), e
582+  F1AD 23               inc hl
583+  F1AE 72               ld (hl), d
584+  F1AF 23               inc hl
585+  F1B0 36 00            ld (hl), 0
586+  F1B2 EB               ex de, hl
587+  F1B3 D1               pop de
588+  F1B4 C9               ret
589+  F1B5
590+  F1B5              set_file_size_in_fcb:
591+  F1B5                  ; Pass HL -> FCB (Note that this is an unusual way to pass it in)
592+  F1B5                  ; Pass file pointer (in 128-byte records) in bcde.
593+  F1B5                  ; Preserves hl
594+  F1B5
595+  F1B5                  ; The following details are from http://www.primrosebank.net/computers/cpm/cpm_software_mfs.htm
596+  F1B5                  ; RC = record counter, goes from 0 to $80. $80 means full, and represents 128*128=16K.
597+  F1B5                  ; EX = 0 for files < 16K, otherwise 1 - 31 for Extents of 16K each.
598+  F1B5                  ; S2 = high byte for the EXc ounter, so if EX wants to be bigger than 31, overflow it into here.
599+  F1B5
600+  F1B5                  ; Split bcde into S2, EX & RC.
601+  F1B5                  ; To do this:
602+  F1B5                  ; RC = e & %0111 1111               (i.e. a number 0..127)
603+  F1B5                  ; Divide bcde by 128                (Shift right 7 bits, or shift left 1 bit then right 8)
604+  F1B5                  ; EX = e & %0001 1111               (i.e. it has a max of 31)
605+  F1B5                  ; Shift left 3 places
606+  F1B5                  ; S2 = d
607+  F1B5
608+  F1B5                  ; RC = e & %0111 1111
609+  F1B5 E5               push hl
610+  F1B6 7B               ld a, e
611+  F1B7 E6 7F            and %01111111                       ; RC is in A
612+  F1B9
613+  F1B9 CB 23            sla e                               ; Shift all left by 1 bit
614+  F1BB CB 12            rl d
615+  F1BD CB 11            rl c
616+  F1BF CB 10            rl b
617+  F1C1
618+  F1C1 5A               ld e, d                             ; Shift all right by 8 bits
619+  F1C2 51               ld d, c
620+  F1C3 48               ld c, b
621+  F1C4 06 00            ld b, 0                             ; We've effectively shifted right by 7 bits
622+  F1C6
623+  F1C6 01 0F 00         ld bc, 15                           ; ex is as FCB+12, s2 is at FCB+14, rc is at FCB + 15
624+  F1C9 09               add hl, bc                          ; hl -> FCB.RC
625+  F1CA 77               ld (hl), a                          ; RC is now stored in FCB
626+  F1CB
627+  F1CB 2B               dec hl
628+  F1CC 2B               dec hl
629+  F1CD 2B               dec hl                              ; hl -> FCB.EX
630+  F1CE 7B               ld a, e
631+  F1CF E6 1F            and %00011111                       ; EX is in A
632+  F1D1 77               ld (hl), a
633+  F1D2
634+  F1D2 CB 23            sla e                               ; Shift all left by 1 bit
635+  F1D4 CB 12            rl d
636+  F1D6 CB 11            rl c
637+  F1D8 CB 10            rl b
638+  F1DA CB 23            sla e                               ; Shift all left by 1 bit
639+  F1DC CB 12            rl d
640+  F1DE CB 11            rl c
641+  F1E0 CB 10            rl b
642+  F1E2 CB 23            sla e                               ; Shift all left by 1 bit
643+  F1E4 CB 12            rl d
644+  F1E6 CB 11            rl c
645+  F1E8 CB 10            rl b
646+  F1EA
647+  F1EA 23               inc hl
648+  F1EB 3E 00            ld a, 0
649+  F1ED 36 00            ld (hl), 0                          ; Blank out the mystery byte called "unused"
650+  F1EF 23               inc hl                              ; hl -> FCB.S2
651+  F1F0
652+  F1F0 7A               ld a, d
653+  F1F1 E6 1F            and %00011111                       ; S2 is in A
654+  F1F3 77               ld (hl), a
655+  F1F4
656+  F1F4 E1               pop hl
657+  F1F5 C9               ret
658+  F1F6
659+  F1F6              convert_user_number_to_folder_name:
660+  F1F6                  ; Pass in 1 to 15 in A.
661+  F1F6                  ; This returns "1" to "F"
662+  F1F6 E6 0F            and %00001111
663+  F1F8 C6 30            add a, '0'                             ; Convert 1-9 => "1".."9"
664+  F1FA FE 3A            cp ':'
665+  F1FC D8               ret c
666+  F1FD C6 07            add a, 7
667+  F1FF C9               ret
668+  F200
669+  F200                  include "memorystick_low_level.asm"
# file opened: memorystick_low_level.asm
  1++ F200              ; memorystick_low_level.asm
  2++ F200              ;--------------------;
  3++ F200              ; LOW LEVEL ROUTINES ;
  4++ F200              ;--------------------;
  5++ F200
  6++ F200              configure_memorystick:
  7++ F200 06 05            ld b, 5                                 ; Have 5 attempts at configuring the module before giving up
  8++ F202              configure_memorystick1:
  9++ F202 C5               push bc
 10++ F203 CD 7E F3         call connect_to_usb_drive
 11++ F206 20 08            jr nz, failed_to_setup
 12++ F208 CD C2 F2         call connect_to_disk
 13++ F20B CD F1 F2         call mount_disk
 14++ F20E C1               pop bc
 15++ F20F C9               ret
 16++ F210              failed_to_setup:
 17++ F210 CD 33 ED         call long_pause
 18++ F213 CD 33 ED         call long_pause
 19++ F216 CD 33 ED         call long_pause
 20++ F219 CD 33 ED         call long_pause
 21++ F21C C1               pop bc
 22++ F21D 10 E3            djnz configure_memorystick1
 23++ F21F CD 83 ED         call message
 24++ F222 43 48 33 37      db 'CH376S error.',13,10,0
 24++ F226 36 53 20 65
 24++ F22A 72 72 6F 72
 24++ F22E 2E 0D 0A 00
 25++ F232 C9               ret
 26++ F233
 27++ F233              ;----------------------------------------------------------------
 28++ F233              ; Call this once at startup
 29++ F233              reset_ch376_module:
 30++ F233 3E 05            ld a, RESET_ALL
 31++ F235 CD 4C F4         call send_command_byte
 32++ F238 CD 33 ED         call long_pause
 33++ F23B CD 33 ED         call long_pause
 34++ F23E C9               ret
 35++ F23F
 36++ F23F              ;-----------------------------------------------------------------
 37++ F23F              check_module_exists:
 38++ F23F 3E 06            ld a, CHECK_EXIST
 39++ F241 CD 4C F4         call send_command_byte
 40++ F244
 41++ F244 3E 7B            ld a, 123               ; We send an arbitrary number
 42++ F246 CD 30 F4         call send_data_byte
 43++ F249
 44++ F249 CD 55 F4         call read_data_byte
 45++ F24C
 46++ F24C FE 84            cp 255-123      ; The result is 255 minus what we sent in
 47++ F24E C8               ret z
 48++ F24F CD 83 ED         call message
 49++ F252 45 52 52 4F      db 'ERROR: CH376S module not found.',13,10,0
 49++ F256 52 3A 20 43
 49++ F25A 48 33 37 36
 49++ F25E 53 20 6D 6F
 49++ F262 64 75 6C 65
 49++ F266 20 6E 6F 74
 49++ F26A 20 66 6F 75
 49++ F26E 6E 64 2E 0D
 49++ F272 0A 00
 50++ F274 C9               ret
 51++ F275
 52++ F275              ;-----------------------------------------------------------------
 53++ F275              get_module_version:
 54++ F275 3E 01            ld a, GET_IC_VER
 55++ F277 CD 4C F4         call send_command_byte
 56++ F27A
 57++ F27A CD 55 F4         call read_data_byte
 58++ F27D E6 1F            and %00011111
 59++ F27F
 60++ F27F CD 83 ED         call message
 61++ F282 46 6F 75 6E      db 'Found CH376S v',0 ; Mine is v3!!!
 61++ F286 64 20 43 48
 61++ F28A 33 37 36 53
 61++ F28E 20 76 00
 62++ F291 CD A1 ED         call show_a_as_hex
 63++ F294 CD 08 ED         call newline
 64++ F297 C9               ret
 65++ F298
 66++ F298              ;-----------------------------------------------------------------
 67++ F298              set_usb_host_mode:
 68++ F298 3E 15            ld a, SET_USB_MODE
 69++ F29A CD 4C F4         call send_command_byte
 70++ F29D 3E 06            ld a, 6
 71++ F29F CD 30 F4         call send_data_byte
 72++ F2A2 CD 91 F4         call read_status_byte
 73++ F2A5 FE 15            cp USB_INT_CONNECT
 74++ F2A7 C8               ret z
 75++ F2A8 CD 83 ED         call message
 76++ F2AB 45 52 52 4F      db 'ERROR: No USB Disk?',13,10,0
 76++ F2AF 52 3A 20 4E
 76++ F2B3 6F 20 55 53
 76++ F2B7 42 20 44 69
 76++ F2BB 73 6B 3F 0D
 76++ F2BF 0A 00
 77++ F2C1 C9               ret
 78++ F2C2
 79++ F2C2              ;-----------------------------------------------------------------
 80++ F2C2              connect_to_disk:
 81++ F2C2 3E 30            ld a, DISK_CONNECT
 82++ F2C4 CD 4C F4         call send_command_byte
 83++ F2C7 3E 22            ld a, GET_STATUS
 84++ F2C9 CD 91 F4         call read_status_byte
 85++ F2CC C8               ret z
 86++ F2CD CD 83 ED         call message
 87++ F2D0 45 52 52 4F      db 'ERROR connecting to USB Disk.',13,10,0
 87++ F2D4 52 20 63 6F
 87++ F2D8 6E 6E 65 63
 87++ F2DC 74 69 6E 67
 87++ F2E0 20 74 6F 20
 87++ F2E4 55 53 42 20
 87++ F2E8 44 69 73 6B
 87++ F2EC 2E 0D 0A 00
 88++ F2F0 C9               ret
 89++ F2F1
 90++ F2F1              ;-----------------------------------------------------------------
 91++ F2F1              mount_disk:
 92++ F2F1 3E 31            ld a, DISK_MOUNT
 93++ F2F3 CD 4C F4         call send_command_byte
 94++ F2F6 3E 22            ld a, GET_STATUS
 95++ F2F8 CD 91 F4         call read_status_byte
 96++ F2FB C8               ret z
 97++ F2FC CD 83 ED         call message
 98++ F2FF 45 52 52 4F      db 'ERROR mounting USB Disk.',13,10,0
 98++ F303 52 20 6D 6F
 98++ F307 75 6E 74 69
 98++ F30B 6E 67 20 55
 98++ F30F 53 42 20 44
 98++ F313 69 73 6B 2E
 98++ F317 0D 0A 00
 99++ F31A C9               ret
100++ F31B
101++ F31B              ;-----------------------------------------------------------------
102++ F31B              read_disk_signature:
103++ F31B 3E 27            ld a, RD_USB_DATA0
104++ F31D CD 4C F4         call send_command_byte
105++ F320 CD 55 F4         call read_data_byte                 ; A = length of bytes to now read
106++ F323 FE 24            cp 36
107++ F325 20 39            jr nz, could_not_read_disk_sig
108++ F327
109++ F327                  ; Ignore the first 8 bytes
110++ F327 06 08            ld b, 8
111++ F329              read_disk_signature1:
112++ F329 C5               push bc
113++ F32A CD 58 F4         call read_data_byte_silent
114++ F32D C1               pop bc
115++ F32E 10 F9            djnz read_disk_signature1
116++ F330
117++ F330                  ; Display the next 8 bytes (Manufacturer)
118++ F330 06 08            ld b, 8
119++ F332              read_disk_signature2:
120++ F332 C5               push bc
121++ F333 CD 58 F4         call read_data_byte_silent
122++ F336 CD DB EC         call print_a
123++ F339 C1               pop bc
124++ F33A 10 F6            djnz read_disk_signature2
125++ F33C CD 08 ED         call newline
126++ F33F
127++ F33F                  ; Display the next 16 bytes (Model)
128++ F33F 06 10            ld b, 16
129++ F341              read_disk_signature3:
130++ F341 C5               push bc
131++ F342 CD 58 F4         call read_data_byte_silent
132++ F345 CD DB EC         call print_a
133++ F348 C1               pop bc
134++ F349 10 F6            djnz read_disk_signature3
135++ F34B
136++ F34B 3E 20            ld a, ' '
137++ F34D CD DB EC         call print_a
138++ F350
139++ F350                  ; Display the next 4 bytes (Version)
140++ F350 06 04            ld b, 4
141++ F352              read_disk_signature4:
142++ F352 C5               push bc
143++ F353 CD 58 F4         call read_data_byte_silent
144++ F356 CD DB EC         call print_a
145++ F359 C1               pop bc
146++ F35A 10 F6            djnz read_disk_signature4
147++ F35C CD 08 ED         call newline
148++ F35F C9               ret
149++ F360
150++ F360              could_not_read_disk_sig:
151++ F360 CD 83 ED         call message
152++ F363 45 52 52 4F      db 'ERROR reading disk sig.',13,10,0
152++ F367 52 20 72 65
152++ F36B 61 64 69 6E
152++ F36F 67 20 64 69
152++ F373 73 6B 20 73
152++ F377 69 67 2E 0D
152++ F37B 0A 00
153++ F37D C9               ret
154++ F37E
155++ F37E              connect_to_usb_drive:
156++ F37E                  ; Connects us up to the USB Drive.
157++ F37E                  ; Returns Zero flag = true if we can connect ok.
158++ F37E CD 33 F2         call reset_ch376_module
159++ F381 CD 98 F2         call set_usb_host_mode
160++ F384 FE 15            cp USB_INT_CONNECT
161++ F386 C9               ret
162++ F387
163++ F387              create_file:
164++ F387                  ; pass in DE = pointer to filename
165++ F387 D5               push de
166++ F388 3E 2F            ld a, SET_FILE_NAME
167++ F38A CD 4C F4         call send_command_byte
168++ F38D E1               pop hl
169++ F38E CD 36 F4         call send_data_string
170++ F391
171++ F391 3E 34            ld a, FILE_CREATE
172++ F393 CD 4C F4         call send_command_byte
173++ F396
174++ F396 CD 91 F4         call read_status_byte
175++ F399 FE 14            cp USB_INT_SUCCESS
176++ F39B C9               ret
177++ F39C
178++ F39C              open_file:
179++ F39C                  ; Tells the module to use the filename from the filename_buffer.
180++ F39C                  ; Returns z=true if ok to proceed.
181++ F39C                  ; Pass in hl -> directory string, e.g. "/folder"
182++ F39C              ;      push hl
183++ F39C              ;      call message
184++ F39C              ;      db 'open_file:[',0
185++ F39C              ;  open_file1:
186++ F39C              ;      ld a, (hl)
187++ F39C              ;      cp 0
188++ F39C              ;      jr z, open_file2
189++ F39C              ;      call print_a
190++ F39C              ;      inc hl
191++ F39C              ;      jr open_file1
192++ F39C
193++ F39C              ;  open_file2:
194++ F39C              ;      ld a, ']'
195++ F39C              ;      call print_a
196++ F39C              ;      call newline
197++ F39C              ;      pop hl
198++ F39C
199++ F39C 3E 2F            ld a, SET_FILE_NAME
200++ F39E CD 4C F4         call send_command_byte
201++ F3A1 CD 36 F4         call send_data_string
202++ F3A4 3E 32            ld a, FILE_OPEN
203++ F3A6 CD 4C F4         call send_command_byte
204++ F3A9 CD 91 F4         call read_status_byte
205++ F3AC FE 14            cp USB_INT_SUCCESS
206++ F3AE C9               ret
207++ F3AF
208++ F3AF              close_file:
209++ F3AF 3E 36            ld a, FILE_CLOSE
210++ F3B1 CD 4C F4         call send_command_byte
211++ F3B4 3E 01            ld a, 1                             ; 1 = update file size if necessary
212++ F3B6 CD 30 F4         call send_data_byte
213++ F3B9 CD 91 F4         call read_status_byte
214++ F3BC C9               ret
215++ F3BD
216++ F3BD              create_directory:
217++ F3BD                  ; Tells the module to use the filename from the filename_buffer to create a directory of that name.
218++ F3BD                  ; Returns z=true if ok to proceed.
219++ F3BD 21 EB FF         ld hl, filename_buffer
220++ F3C0              ; create_directory1:
221++ F3C0              ;     ld a, (hl)
222++ F3C0              ;     cp 0
223++ F3C0              ;     jr z, create_directory2
224++ F3C0              ;     inc hl
225++ F3C0              ;     call print_a
226++ F3C0              ;     jr create_directory1
227++ F3C0
228++ F3C0              create_directory2:
229++ F3C0
230++ F3C0 3E 2F            ld a, SET_FILE_NAME
231++ F3C2 CD 4C F4         call send_command_byte
232++ F3C5 21 EB FF         ld hl, filename_buffer
233++ F3C8 CD 36 F4         call send_data_string
234++ F3CB 3E 40            ld a, DIR_CREATE
235++ F3CD CD 4C F4         call send_command_byte
236++ F3D0 CD 91 F4         call read_status_byte
237++ F3D3 FE 14            cp USB_INT_SUCCESS
238++ F3D5 C9               ret
239++ F3D6
240++ F3D6              read_from_file:
241++ F3D6                  ; Ask to read 128 bytes from the current file into the dma_address area pointed to by DE.
242++ F3D6                  ; Returns Zero flag set for success, clear for fail.
243++ F3D6 D5               push de
244++ F3D7 3E 3A            ld a, BYTE_READ
245++ F3D9 CD 4C F4         call send_command_byte
246++ F3DC 3E 80            ld a, 128                           ; Request 128 bytes
247++ F3DE CD 30 F4         call send_data_byte
248++ F3E1 3E 00            ld a, 0
249++ F3E3 CD 30 F4         call send_data_byte
250++ F3E6
251++ F3E6 CD 91 F4         call read_status_byte
252++ F3E9              read_from_file1:
253++ F3E9 FE 1D            cp USB_INT_DISK_READ                    ; This means "go ahead and read"
254++ F3EB 28 07            jr z, read_from_file3
255++ F3ED FE 14            cp USB_INT_SUCCESS                      ; Bizarrely this means we are finished
256++ F3EF CA 20 F4         jp z, read_from_file_cannot
257++ F3F2 18 2C            jr read_from_file_cannot
258++ F3F4
259++ F3F4              read_from_file3:
260++ F3F4 3E 27            ld a, RD_USB_DATA0                      ; Find out how many bytes are available to read
261++ F3F6 CD 4C F4         call send_command_byte
262++ F3F9 CD 55 F4         call read_data_byte                     ; A = number of bytes available to read
263++ F3FC
264++ F3FC                  ; If there are less than 128 bytes to read, fill the buffer with 0s first
265++ F3FC FE 80            cp 128
266++ F3FE 30 0B            jr nc, read_from_file_128
267++ F400 E1               pop hl
268++ F401 E5               push hl
269++ F402 F5               push af
270++ F403 06 80            ld b, 128
271++ F405              read_from_file_padding:
272++ F405 36 00            ld (hl), 0
273++ F407 23               inc hl
274++ F408 10 FB            djnz read_from_file_padding
275++ F40A F1               pop af
276++ F40B
277++ F40B              read_from_file_128:
278++ F40B E1               pop hl
279++ F40C CD 5E F4         call read_data_bytes_into_hl        ; Read this block of data
280++ F40F E5               push hl
281++ F410 3E 3B            ld a, BYTE_RD_GO
282++ F412 CD 4C F4         call send_command_byte
283++ F415 3E 22            ld a, GET_STATUS
284++ F417 CD 4C F4         call send_command_byte
285++ F41A CD 55 F4         call read_data_byte
286++ F41D E1               pop hl
287++ F41E                  ; All done, so return ZERO for success
288++ F41E BF               cp a                                ; set zero flag for success
289++ F41F C9               ret
290++ F420
291++ F420              read_from_file_cannot:
292++ F420 D1               pop de
293++ F421 F6 01            or 1                                ; clear zero flag
294++ F423 C9               ret
295++ F424
296++ F424              copy_filename_to_buffer:
297++ F424                  ; Enter with hl->zero-terminated-filename-string
298++ F424                  ; Copies this to filename_buffer
299++ F424 11 EB FF         ld de, filename_buffer
300++ F427              copy_filename_to_buffer1:
301++ F427 7E               ld a, (hl)
302++ F428 12               ld (de), a
303++ F429 23               inc hl
304++ F42A 13               inc de
305++ F42B FE 00            cp 0
306++ F42D C8               ret z
307++ F42E 18 F7            jr copy_filename_to_buffer1
308++ F430
309++ F430              send_data_byte:
310++ F430                  ; push af
311++ F430                  ; call message
312++ F430                  ; db 'send_data_byte ', 0
313++ F430                  ; pop af
314++ F430                  ; push af
315++ F430                  ; call show_a_as_hex
316++ F430                  ; call newline
317++ F430                  ; pop af
318++ F430 D3 A0            out (mem_stick_data_port), a
319++ F432                  ;call tiny_pause
320++ F432 CD 66 F4         call wait_til_not_busy
321++ F435 C9               ret
322++ F436
323++ F436              send_data_string:
324++ F436                  ; The string is pointed to by HL
325++ F436 7E               ld a, (hl)
326++ F437 FE 00            cp 0
327++ F439 28 0B            jr z, send_data_string_done
328++ F43B F5               push af
329++ F43C E5               push hl
330++ F43D CD 30 F4         call send_data_byte
331++ F440 E1               pop hl
332++ F441 F1               pop af
333++ F442 23               inc hl
334++ F443 C3 36 F4         jp send_data_string
335++ F446              send_data_string_done:
336++ F446 3E 00            ld a, 0
337++ F448 CD 30 F4         call send_data_byte
338++ F44B C9               ret
339++ F44C
340++ F44C              send_command_byte:
341++ F44C                  ; push af
342++ F44C                  ; call message
343++ F44C                  ; db 'send_command_byte ',0
344++ F44C                  ; pop af
345++ F44C                  ; push af
346++ F44C                  ; call show_a_as_hex
347++ F44C                  ; call newline
348++ F44C                  ; pop af
349++ F44C D3 A1            out (mem_stick_command_port), a
350++ F44E                  ;call tiny_pause
351++ F44E CD 66 F4         call wait_til_not_busy
352++ F451 C9               ret
353++ F452
354++ F452              read_command_byte:
355++ F452                  ; call message
356++ F452                  ; db 'read_command_byte: ', 0
357++ F452 DB A1            in a, (mem_stick_command_port)
358++ F454                  ; push af
359++ F454                  ; call show_a_as_hex
360++ F454                  ; call newline
361++ F454                  ; pop af
362++ F454 C9               ret
363++ F455
364++ F455              read_data_byte:
365++ F455                  ; call message
366++ F455                  ; db 'read_data_byte: ', 0
367++ F455 DB A0            in a, (mem_stick_data_port)
368++ F457                  ; push af
369++ F457                  ; call show_a_as_hex
370++ F457                  ; call newline
371++ F457                  ; pop af
372++ F457 C9               ret
373++ F458
374++ F458              read_data_byte_silent:
375++ F458 DB A0            in a, (mem_stick_data_port)
376++ F45A C9               ret
377++ F45B
378++ F45B              read_data_bytes_into_buffer:
379++ F45B                  ; The number of bytes should be in A.
380++ F45B                  ; Read that many bytes into the buffer.
381++ F45B                  ; The value of A is retained.
382++ F45B 21 C5 FF         ld hl, disk_buffer
383++ F45E              read_data_bytes_into_hl:
384++ F45E                  ; This entry point will read A bytes into the area pointed to by HL.
385++ F45E                  ; On exit HL will point to the location after where the bytes were added.
386++ F45E F5               push af
387++ F45F 47               ld b, a
388++ F460 0E A0            ld c, mem_stick_data_port
389++ F462              read_data_bytes_into_buffer1:
390++ F462 ED B2            inir                    ; A rare use of In, Increase & Repeat!!!
391++ F464 F1               pop af
392++ F465 C9               ret
393++ F466
394++ F466              wait_til_not_busy:
395++ F466                  ; call message
396++ F466                  ; db 'waiting...', 13, 10, 0
397++ F466 01 60 EA         ld bc, 60000            ; retry max 60000 times!!!
398++ F469              wait_til_not_busy1:
399++ F469 C5               push bc
400++ F46A CD 52 F4         call read_command_byte
401++ F46D E6 10            and %00010000
402++ F46F C2 74 F4         jp nz, wait_til_not_busy2
403++ F472 C1               pop bc
404++ F473 C9               ret
405++ F474              wait_til_not_busy2:
406++ F474 CD 3D ED         call short_pause
407++ F477 C1               pop bc
408++ F478 0B               dec bc
409++ F479 78               ld a, b
410++ F47A B1               or c
411++ F47B 20 EC            jr nz, wait_til_not_busy1
412++ F47D CD 83 ED         call message
413++ F480 5B 55 53 42      db '[USB TIMEOUT]', 13, 10, 0
413++ F484 20 54 49 4D
413++ F488 45 4F 55 54
413++ F48C 5D 0D 0A 00
414++ F490 C9               ret
415++ F491
416++ F491              read_status_byte:
417++ F491 3E 22            ld a, GET_STATUS
418++ F493 CD 4C F4         call send_command_byte
419++ F496 CD 55 F4         call read_data_byte
420++ F499 C9               ret
421++ F49A
422++ F49A              ; show_status:
423++ F49A              ;     call read_status_byte
424++ F49A              ;     push af
425++ F49A              ;     call report_on_status
426++ F49A              ;     pop af
427++ F49A              ;     ret                     ; The status is returned in A
428++ F49A
429++ F49A              ; report_on_status:
430++ F49A              ;     cp USB_INT_SUCCESS
431++ F49A              ;     jr nz, ros1
432++ F49A              ;     call message
433++ F49A              ;     db 'USB_INT_SUCCESS',13,10,0
434++ F49A              ;     ret
435++ F49A              ; ros1:
436++ F49A              ;     cp USB_INT_CONNECT
437++ F49A              ;     jr nz, ros2
438++ F49A              ;     call message
439++ F49A              ;     db 'USB_INT_CONNECT',13,10,0
440++ F49A              ;     ret
441++ F49A              ; ros2:
442++ F49A              ;     cp USB_INT_DISCONNECT
443++ F49A              ;     jr nz, ros3
444++ F49A              ;     call message
445++ F49A              ;     db 'USB_INT_DISCONNECT',13,10,0
446++ F49A              ;     ret
447++ F49A              ; ros3:
448++ F49A              ;     cp USB_INT_BUF_OVER
449++ F49A              ;     jr nz, ros4
450++ F49A              ;     call message
451++ F49A              ;     db 'USB_INT_BUF_OVER',13,10,0
452++ F49A              ;     ret
453++ F49A              ; ros4:
454++ F49A              ;     cp USB_INT_USB_READY
455++ F49A              ;     jr nz, ros5
456++ F49A              ;     call message
457++ F49A              ;     db 'USB_INT_USB_READY',13,10,0
458++ F49A              ;     ret
459++ F49A              ; ros5:
460++ F49A              ;     cp USB_INT_DISK_READ
461++ F49A              ;     jr nz, ros6
462++ F49A              ;     call message
463++ F49A              ;     db 'USB_INT_DISK_READ',13,10,0
464++ F49A              ;     ret
465++ F49A              ; ros6:
466++ F49A              ;     cp USB_INT_DISK_WRITE
467++ F49A              ;     jr nz, ros7
468++ F49A              ;     call message
469++ F49A              ;     db 'USB_INT_DISK_WRITE',13,10,0
470++ F49A              ;     ret
471++ F49A              ; ros7:
472++ F49A              ;     cp USB_INT_DISK_ERR
473++ F49A              ;     jr nz, ros8
474++ F49A              ;     call message
475++ F49A              ;     db 'USB_INT_DISK_ERR',13,10,0
476++ F49A              ;     ret
477++ F49A              ; ros8:
478++ F49A              ;     cp YES_OPEN_DIR
479++ F49A              ;     jr nz, ros9
480++ F49A              ;     call message
481++ F49A              ;     db 'YES_OPEN_DIR',13,10,0
482++ F49A              ;     ret
483++ F49A              ; ros9:
484++ F49A              ;     cp ERR_MISS_FILE
485++ F49A              ;     jr nz, ros10
486++ F49A              ;     call message
487++ F49A              ;     db 'ERR_MISS_FILE',13,10,0
488++ F49A              ;     ret
489++ F49A              ; ros10:
490++ F49A              ;     cp ERR_FOUND_NAME
491++ F49A              ;     jr nz, ros11
492++ F49A              ;     call message
493++ F49A              ;     db 'ERR_FOUND_NAME',13,10,0
494++ F49A              ;     ret
495++ F49A              ; ros11:
496++ F49A              ;     cp ERR_DISK_DISCON
497++ F49A              ;     jr nz, ros12
498++ F49A              ;     call message
499++ F49A              ;     db 'ERR_DISK_DISCON',13,10,0
500++ F49A              ;     ret
501++ F49A              ; ros12:
502++ F49A              ;     cp ERR_LARGE_SECTOR
503++ F49A              ;     jr nz, ros13
504++ F49A              ;     call message
505++ F49A              ;     db 'ERR_LARGE_SECTOR',13,10,0
506++ F49A              ;     ret
507++ F49A              ; ros13:
508++ F49A              ;     cp ERR_TYPE_ERROR
509++ F49A              ;     jr nz, ros14
510++ F49A              ;     call message
511++ F49A              ;     db 'ERR_TYPE_ERROR',13,10,0
512++ F49A              ;     ret
513++ F49A              ; ros14:
514++ F49A              ;     cp ERR_BPB_ERROR
515++ F49A              ;     jr nz, ros15
516++ F49A              ;     call message
517++ F49A              ;     db 'ERR_BPB_ERROR',13,10,0
518++ F49A              ;     ret
519++ F49A              ; ros15:
520++ F49A              ;     cp ERR_DISK_FULL
521++ F49A              ;     jr nz, ros16
522++ F49A              ;     call message
523++ F49A              ;     db 'ERR_DISK_FULL',13,10,0
524++ F49A              ;     ret
525++ F49A              ; ros16:
526++ F49A              ;     cp ERR_FDT_OVER
527++ F49A              ;     jr nz, ros17
528++ F49A              ;     call message
529++ F49A              ;     db 'ERR_FDT_OVER',13,10,0
530++ F49A              ;     ret
531++ F49A              ; ros17:
532++ F49A              ;     cp ERR_FILE_CLOSE
533++ F49A              ;     jr nz, ros18
534++ F49A              ;     call message
535++ F49A              ;     db 'ERR_FILE_CLOSE',13,10,0
536++ F49A              ;     ret
537++ F49A              ; ros18:
538++ F49A              ;     call message
539++ F49A              ;     db 'UNKNOWN STATUS: ',0
540++ F49A              ;     call show_a_as_hex
541++ F49A              ;     call newline
542++ F49A              ;     ret
543++ F49A
544++ F49A
545++ F49A              mem_stick_data_port     equ 0xA0
546++ F49A              mem_stick_command_port  equ 0xA1
547++ F49A
548++ F49A              GET_IC_VER equ $01
549++ F49A              SET_BAUDRATE equ $02
550++ F49A              RESET_ALL equ $05
551++ F49A              CHECK_EXIST equ $06
552++ F49A              GET_FILE_SIZE equ $0C
553++ F49A              SET_USB_MODE equ $15
554++ F49A              GET_STATUS equ $22
555++ F49A              RD_USB_DATA0 equ $27
556++ F49A              WR_USB_DATA equ $2C
557++ F49A              WR_REQ_DATA equ $2D
558++ F49A              WR_OFS_DATA equ $2E
559++ F49A              SET_FILE_NAME equ $2F
560++ F49A              DISK_CONNECT equ $30
561++ F49A              DISK_MOUNT equ $31
562++ F49A              FILE_OPEN equ $32
563++ F49A              FILE_ENUM_GO equ $33
564++ F49A              FILE_CREATE equ $34
565++ F49A              FILE_ERASE equ $35
566++ F49A              FILE_CLOSE equ $36
567++ F49A              DIR_INFO_READ equ $37
568++ F49A              DIR_INFO_SAVE equ $38
569++ F49A              BYTE_LOCATE equ $39
570++ F49A              BYTE_READ equ $3A
571++ F49A              BYTE_RD_GO equ $3B
572++ F49A              BYTE_WRITE equ $3C
573++ F49A              BYTE_WR_GO equ $3D
574++ F49A              DISK_CAPACITY equ $3E
575++ F49A              DISK_QUERY equ $3F
576++ F49A              DIR_CREATE equ $40
577++ F49A
578++ F49A
579++ F49A              ; Statuses
580++ F49A              USB_INT_SUCCESS equ $14
581++ F49A              USB_INT_CONNECT equ $15
582++ F49A              USB_INT_DISCONNECT equ $16
583++ F49A              USB_INT_BUF_OVER equ $17
584++ F49A              USB_INT_USB_READY equ $18
585++ F49A              USB_INT_DISK_READ equ $1D
586++ F49A              USB_INT_DISK_WRITE equ $1E
587++ F49A              USB_INT_DISK_ERR equ $1F
588++ F49A              YES_OPEN_DIR equ $41
589++ F49A              ERR_MISS_FILE equ $42
590++ F49A              ERR_FOUND_NAME equ $43
591++ F49A              ERR_DISK_DISCON equ $82
592++ F49A              ERR_LARGE_SECTOR equ $84
593++ F49A              ERR_TYPE_ERROR equ $92
594++ F49A              ERR_BPB_ERROR equ $A1
595++ F49A              ERR_DISK_FULL equ $B1
596++ F49A              ERR_FDT_OVER equ $B2
597++ F49A              ERR_FILE_CLOSE equ $B4
598++ F49A
599++ F49A              ROOT_DIRECTORY:
600++ F49A 2A 00            db '*',0
601++ F49C
602++ F49C              SLASH:
603++ F49C 2F 00            db '/',0
604++ F49E
605++ F49E              ;SAVE_FILENAME:
606++ F49E              ;    db 'TESTING',0
607++ F49E
608++ F49E              ;TARGET_FILENAME:
609++ F49E              ;    db '/TARGET2.TXT',0
610++ F49E
611++ F49E              ;NO_EXTENSION:
612++ F49E              ;    db '   ',0
613++ F49E
614++ F49E              ;TXT_EXTENSION:
615++ F49E              ;    db 'TXT',0
616++ F49E
# file closed: memorystick_low_level.asm
670+  F49E
671+  F49E              ROOT_NAME:
672+  F49E 2F 00            db '/',0
673+  F4A0
674+  F4A0              STAR_DOT_STAR:
675+  F4A0 2A 00            db '*',0
676+  F4A2
677+  F4A2              CPM_FOLDER_NAME:
678+  F4A2 2F 43 50 4D      db '/CPM',0
678+  F4A6 00
679+  F4A7
680+  F4A7              TINY_BASIC_FOLDER_NAME:
681+  F4A7 2F 54 42 41           db '/TBASIC',0
681+  F4AB 53 49 43 00
682+  F4AF
683+  F4AF              CPM_DISKS_NAME:
684+  F4AF 44 49 53 4B      db 'DISKS',0
684+  F4B3 53 00
685+  F4B5
686+  F4B5
687+  F4B5
# file closed: memorystick.asm
126   F4B5                  include "PPI.asm"
# file opened: PPI.asm
  1+  F4B5              INIT_PIO:
  2+  F4B5 3E 80                	LD      A, 0x80 			; All ports output A,B and C
  3+  F4B7 D3 AB        	        OUT     (PIO_M), A		;
  4+  F4B9 C9                       RET
  5+  F4BA
  6+  F4BA
  7+  F4BA              change_to_slot2:
  8+  F4BA E5               push    HL
  9+  F4BB
 10+  F4BB                  ;call    teste_na_rom
 11+  F4BB 3E AA        	LD      A, 0xAA
 12+  F4BD D3 A8        	OUT     (PIO_A), A
 13+  F4BF                  ;call    teste_na_ram
 14+  F4BF
 15+  F4BF
 16+  F4BF                  ; Copy the first 16k of ROM down to ram LD (DE),(HL),
 17+  F4BF 21 CB F4     	ld hl,  RamAddr000
 18+  F4C2 11 00 00     	ld de,  0
 19+  F4C5 01 80 00     	ld bc,	128
 20+  F4C8 ED B0        	ldir
 21+  F4CA C9               ret
 22+  F4CB
 23+  F4CB
 24+  F4CB              ;teste_na_ram:
 25+  F4CB                  ;call CORE_message
 26+  F4CB                  ;db 'Testing ram 1000: ',13,10,0
 27+  F4CB                  ;ld  hl,1000
 28+  F4CB                  ;ld  A, 0xA5
 29+  F4CB                  ;ld  (hl),a
 30+  F4CB                  ;ld  A, 0x5A
 31+  F4CB                  ;ld A,(hl)
 32+  F4CB                  ;cp  A, 0xA5
 33+  F4CB                  ;jp  NZ, cont
 34+  F4CB                  ;call CORE_message
 35+  F4CB                  ;db 'We are in RAM',13,10,0
 36+  F4CB                  ;jp  cont2
 37+  F4CB              ;cont:
 38+  F4CB                  ;call CORE_message
 39+  F4CB                  ;db 'We are NOT in RAM',13,10,0
 40+  F4CB              ;    halt
 41+  F4CB              ;cont2:
 42+  F4CB              ;    pop     HL
 43+  F4CB              ;copy_ram:
 44+  F4CB              ;    ret
 45+  F4CB
 46+  F4CB              ;teste_na_rom:
 47+  F4CB              ;    call CORE_message
 48+  F4CB              ;    db 'Testing ram 1000: ',13,10,0
 49+  F4CB              ;    ld  hl,1000
 50+  F4CB              ;    ld  A, 0xA5
 51+  F4CB              ;    ld  (hl),a
 52+  F4CB              ;    ld  A, 0x5A
 53+  F4CB              ;    ld A,(hl)
 54+  F4CB              ;    cp  A, 0xA5
 55+  F4CB              ;    jp  NZ, cont1
 56+  F4CB              ;    call CORE_message
 57+  F4CB              ;    db 'We are in RAM',13,10,0
 58+  F4CB              ;    jp  cont21
 59+  F4CB              ;cont1:
 60+  F4CB              ;    call CORE_message
 61+  F4CB              ;    db 'We are NOT in RAM',13,10,0
 62+  F4CB              ;cont21:
 63+  F4CB              ;    ret
# file closed: PPI.asm
127   F4CB                  include "cpm000.asm"
# file opened: cpm000.asm
  1+  F4CB                  ;org     0x0000
  2+  F4CB              RamAddr000:
  3+  F4CB C3 00 DC         jp      BIOS_START      ;Warm boot jump to bios
  4+  F4CE 03               db      0x3               ;iobyte
  5+  F4CF 00               DS      1               ;disk byte
  6+  F4D0 C3 00 D0         jp      BDOS_START      ;system call
  7+  F4D3                  ;Restart vector 7  generally used by debuggers
  8+  F4D3              	;org 0x0038
  9+  F4D3              int:
 10+  F4D3 ED 4D        	reti
 11+  F4D5                  ;Bios work area
 12+  F4D5                  ;org 0x0040
 13+  F4D5 30 30 30 30      db  '0000000000000000'
 13+  F4D9 30 30 30 30
 13+  F4DD 30 30 30 30
 13+  F4E1 30 30 30 30
 14+  F4E5                  ;Unused area in CP/M 2.2
 15+  F4E5                  ;org 0x0050
 16+  F4E5 30 30 30 30      db  '0000000000000000'
 16+  F4E9 30 30 30 30
 16+  F4ED 30 30 30 30
 16+  F4F1 30 30 30 30
 17+  F4F5                  ;FCB Default file control block
 18+  F4F5                  ;org 0x0060
 19+  F4F5 30 30 30 30      db  '0000000000000000'
 19+  F4F9 30 30 30 30
 19+  F4FD 30 30 30 30
 19+  F501 30 30 30 30
 20+  F505 30 30 30 30      db  '0000000000000000'
 20+  F509 30 30 30 30
 20+  F50D 30 30 30 30
 20+  F511 30 30 30 30
 21+  F515                  ;File buffer 128 bytes
 22+  F515                  ;org 0x0080
 23+  F515                  ;db  '0000000000000000000000000000000000000000000000000000000000000000'
 24+  F515                  ;db  '0000000000000000000000000000000000000000000000000000000000000000'
 25+  F515
# file closed: cpm000.asm
128   F515
129   F515              filename_buffer 	equ 65535-20
130   F515              DRIVE_NAME 			equ filename_buffer-2
131   F515              disk_buffer 		equ DRIVE_NAME-36
132   F515
133   F515              CORE_END equ $
134   F515
135   F515                  IF CORE_END-CORE_START>CORE_SIZE
136   F515 ~                    .WARNING "The CORE is too big! CORE_SIZE bytes max!"
137   F515                  ENDIF
# file closed: core.asm
